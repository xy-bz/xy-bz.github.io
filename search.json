[{"title":"使用ssh-key远程登录","date":"2020-08-07T12:58:42.000Z","url":"/2020/08/07/%E4%BD%BF%E7%94%A8ssh-key%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":" 以前用密码登录的时候，总有一大推异常登录，后面了解到可能是攻击，一直用弱密码的话如果再不加管理，被试出来风险很高，于是今天换成了ssh-key的验证方式 ssh 生成一对“公钥/私钥对”，服务器持有公钥，本地持有私钥。 客户端向服务器发出请求。服务器收到请求之后，先在用户的主目录下找到该用户的公钥，然后对比用户发送过来的公钥。如果一致，服务器用公钥加密“质询”并发送给客户端。客户端收到“质询”后用私钥解密，再发还给服务器。认证结束。 基于密钥的安全认证 安装环境 步骤 1.生成SSH-Key 在 ~.ssh 下会生成私钥 id_rsa, 公钥id_rsa.pub 把公钥xxx.pub保存到 ~/.ssh/authorized_keys 中 2.配置服务器 3.修改权限 这一步很重要，我就翻车了 4.配置xshell 配置相应参数，方法改为Public Key，选择文件为1中生成的私钥"},{"title":"HTTPS相关知识","date":"2020-08-04T07:18:44.000Z","url":"/2020/08/04/HTTPS%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","tags":[["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"],["转载","/tags/%E8%BD%AC%E8%BD%BD/"]],"categories":[[" ",""]],"content":" 今天网站认证证书被替换了， 由于github使用了 HSTS，所以被拦截了，被迫学习了下网络知识 知识点 转载于自建CA证书搭建https服务器 1、HTTPS简介HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全。HTTPS和HTTP的区别主要如下： https协议需要到CA（Certificate Authority 即颁发数字证书的机构）申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。 转载于Https 建立安全连接的过程（SSL原理） 2、一个加密通信过程的演化 我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信： 2.1 第一回合：“客户”-&gt;“服务器”：你好 “服务器”-&gt;“客户”：你好，我是服务器 “客户”-&gt;“服务器”：？？？？ 因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下： “客户”-&gt;“服务器”：你好 “服务器”-&gt;“客户”：你好，我是服务器 \\“客户”-&gt;“黑客”：你好** // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器” \\“黑客”-&gt;“客户”：你好，我是服务器** 因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下： 2.2 第二回合：“客户”-&gt;“服务器”：你好 “服务器”-&gt;“客户”：你好，我是服务器 “客户”-&gt;“服务器”：向我证明你就是服务器 “服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA] \\//\\ *\\***注******意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的**** {你好，我是服务器}[私钥|RSA] \\就表示用\\*\\*私钥****对**“你好，我是服务器”**进行加密后的结果。\\ 为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。 “客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，*\\*由并且只能由****公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。 假设“黑客”想冒充“服务器”： \\“黑客”-&gt;“客户”：你好，我是服务器** \\“客户”-&gt;“黑客”：向我证明你就是服务器** \\“黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]** //这里黑客无法冒充，因为他不知道**私钥**，无法用**私钥**加密某个字符串后发送给客户去验证。 “客户”-&gt;“黑客”：？？？？ 由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！ 到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示： 2.3 第三回合：“客户”-&gt;“服务器”：你好 “服务器”-&gt;“客户”：你好，我是服务器 “客户”-&gt;“服务器”：向我证明你就是服务器 “服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA] “客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA] “服务器”-&gt;“客户”：{你的余额是100元}[私钥|RSA] 注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。 这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示： 2.4 第四回合：“客户”-&gt;“服务器”：你好 “服务器”-&gt;“客户”：你好，我是服务器 “客户”-&gt;“服务器”：向我证明你就是服务器 “服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA] “客户”-&gt;“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA] //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。 “服务器”-&gt;“客户”：{OK，收到！}[密钥|对称加密算法] “客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法] “服务器”-&gt;“客户”：{你的余额是100元}[密钥|对称加密算法] 在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。 由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。 总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个： 因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。 客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。 如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。) 到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。 但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法： a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。 b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。 但是这个两个方法都有一定的问题， 对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。 对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下： “客户”-&gt;“黑客”：你好 //黑客截获“客户”发给“服务器”的消息 “黑客”-&gt;“客户”：你好，我是服务器，这个是我的公钥 //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥 “客户”-&gt;“黑客”：向我证明你就是服务器 “黑客”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA] //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器” 因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。 为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容： 证书的发布机构 证书的有效期 公钥 证书所有者（Subject） 签名所使用的算法 指纹以及指纹算法 证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证\\****数字******证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份**。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下： 2.5 第五回合：“客户”-&gt;“服务器”：你好 “服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 //这里用证书代替了公钥 “客户”-&gt;“服务器”：向我证明你就是服务器 “服务器”-&gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA] 注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下： 2.6 完整过程：\\step1**： “客户”向服务端发送一个通信请求 “客户”-&gt;“服务器”：你好 \\step2**： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有 “服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 \\step3**： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。 “客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串 //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。 “服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA] \\step4**： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。 “服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法] “客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法] “服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法] …… //继续其它的通信"},{"title":"常微分方程02","date":"2020-07-15T06:55:56.000Z","url":"/2020/07/15/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B02/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]]},{"title":"栈","date":"2020-07-14T07:27:27.000Z","url":"/2020/07/14/%E6%A0%88/","tags":[["考研","/tags/%E8%80%83%E7%A0%94/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[[" ",""]],"content":" 大话数据结构中有这样一段开场白 早先由于子弹质量问题，军官们都爱用左轮手枪，而非弹夹式手枪 因为弹夹式手枪，子弹叠在一起，如果当中有一颗是卡住了的臭弹， 那么就得卸下弹夹把臭蛋取下来，才能用下面的子弹；而左轮手枪如果遇到臭弹，转到下一颗就解决了；在战场上，子弹卡壳还得卸下来再装上去，也许这点时间，生命就没了 其实，这种弹夹构造就类似栈(stack ) 栈的定义 本质也是线性表 栈(stack )：限定仅在表尾进行插入和删除操作的线性表 栈顶(top)：允许插入和删除的一端 栈底(bottom)：栈顶对应的另一端 空栈： 不含任何数据元素的栈 栈又称为**后进先出(Last In First Out)**的线性表，简称LIFO结构 插入操作，叫作进栈，也称压栈、入栈 删除操作，叫作出栈 进栈出栈变化形式讨论一下进栈顺序为123的出栈顺序（全部进出一遍要6步 ） 第一步 第二步 第三步 第四步 第五步 第六步 1进 2进 3进 3出 2出 1出 1进 2进 2出 3进 3出 1出 1进 2进 2出 1出 3进 3出 1进 1出 2进 2出 3进 3出 1进 1出 2进 3进 3出 2出 不可能是312的原因是3都入栈了，12肯定就入栈了，所以2一定先出栈 1是最先进栈的，但不一定是最后出栈的，所以先进后出这种情况并不一定 栈的顺序存储结构顺序存储就是一组地址连续的存储单元，依次存放自栈底到栈 的数据元素 栈的链式存储结构链式存储就是一组地址不连续的存储单元，通过指针前驱指向后继 栈只有栈顶做插入删除，由于单链表有头指针，而栈顶指针是必须的，所以比较好的办法是把栈顶放在单链表的头部；对于栈而言，也就不需要头结点了 但对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL 栈的基本操作 方法 作用 InitStack( &amp;s) 构造一个空栈s DestroyStack( &amp;S) 初始条件:栈s已存在操作结果：销毁栈s ClearStack( &amp;S) 初始条件:栈s已存在操作结果:清空栈 StackEnpty(S) 初始条件:栈s已存在操作结果:判断栈是否为空，是返回TRUE,否则FALSE StackLength(S) 初始条件:栈s已存在操作结果:返回栈的长度 GetTop(s, &amp;e) 初始条件:栈S已存在且非空操作结果;用e返回s的栈顶元素 Push(&amp;s, e) 初始条件:栈S已存在操作结果:插人元素e为新的栈顶元素 "},{"title":"托管代码到码云","date":"2020-07-13T18:02:49.000Z","url":"/2020/07/14/%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E5%88%B0%E7%A0%81%E4%BA%91/","tags":[["blog","/tags/blog/"]],"categories":[[" ",""]],"content":" 由于墙实在是太强了，导致我在GitHub上托管的代码，没有科学手段有时甚至无法访问；即使能访问，那速度也很慢，于是决定将代码托管到码云上，记录一下 1.生成SSH-Key -f 后设置路径和key名，如果有其他的建议区分 2.添加配置 由于我有github和gitee的，所以要配置一下，在 ~/.ssh 目录下新建一个config配置文件 属性 含义 Host git服务器的域名 HostName git服务器的域名 IdentityFile 私钥路径 3.添加公钥 在gitee上找到ssh设置，找到生成的公钥.pub文件，复制上去 4.测试 显示成功则通过 5.配置git 我是让github和gitee一起使用 中间省略了gitee创建仓库配置的过程，如要按此教程来请注意"},{"title":"常微分方程01","date":"2020-07-13T08:25:10.000Z","url":"/2020/07/13/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B01/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"概念微分方程含有未知函数及其导数(或者微分)的方程称为微分方程.一般写成 y的n阶导数不能缺 常微分方程未知函数是一元函数的微分方程称为常微分方程 微分方程的阶方程中知函数导数的最高阶数称为微分方程的阶 如:y’‘‘-y’‘+6y=0就是三阶微分方程 微分方程的解若将函数代人微分方程,使方程成为恒等式,则该函数称为微分方程的解，这个解是个函数 微分方程的通解若微分方程的解中含有的独立常数的个数等于微分方程的阶数，则该解称为微分方程的通解 初始条件与特解确定通解中常数的条件就是初始条件，确定了通解中的常数后,解就成了特解 一阶微分方程求解变量可分离型能写成y’= f(x)g(y)形式的方程称为变量可分离型方程.解法为 可化为变量可分离型(1)形如dy/dx= f(ax+by+c)的方程,其中常数a,b全都不为零.其解法为令u=ax+by+c,则du/dx=a+b dy/dx 代入原方程得du/dx=a+bf(u) (2)齐次型微分方程 "},{"title":"二重积分02","date":"2020-07-06T08:25:35.000Z","url":"/2020/07/06/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%8602/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"计算直角坐标系 后积先定限，限内画条线，先交写下限，后交写下限 对f(x,y)的其它情形(比如z为负)，利用积分区域的可加性， 也可以化成累次积分。 若积分区域比较复杂, 则须对它进行划分，使分割后 的区域为简单区域。 极坐标系 用极坐标系的信号 先看被积函数是否为f(x2+y2) (平方和)，f(x/y) 积分区域是否为圆或者圆的一部分 如果两者兼是,那么优先选用极坐标系。否则，就优先考虑直角坐标系 极直互化"},{"title":"小王子和狐狸","date":"2020-07-01T07:47:41.000Z","url":"/2020/07/01/%E5%B0%8F%E7%8E%8B%E5%AD%90%E5%92%8C%E7%8B%90%E7%8B%B8/","tags":[["转载","/tags/%E8%BD%AC%E8%BD%BD/"]],"categories":[[" ",""]],"content":"“我是一只狐狸。“狐狸说。 “来和我一起玩吧,小王子建议道，“我很不开心。” “我不能和你一起玩.“狐狸说,“我还没有被驯服呢。” “哦，真对不起。“小王子说。 但是。思索了一会儿，他又问道:“驯服是什么意思呀?“ “你不是本地人。“狐狸说,“你在寻我什么呢?” “我在找人。“小王子说，“驯服是什么意思呀?“ ”人,“狐狸说，“他们有枪，他们还打猎，这太可恶了!但他们也养鸡。这是人唯一的可取之处，你也是来寻找鸡的吗?” 不.。小王子说,“我是来找朋友的。‘**驯服是什么意思呀?**” “这是一件已经被人遗忘了的事情,“狐狸说.“它的意思就是建立联 “建立联系?” “是这样的。“狐狸说。“对我来说，你还只是一个小男孩，和其他千万个小男孩一样。我不需要你,你也同样不需要我。对你来说,我也不过是和其他千万只狐狸一样的一只普通狐狸。但是，如果你驯服了我,我们就互相不可缺少了。对我来说,你就是世界上唯一的了;对你来说,我也将是世界上唯一的了。” “我开始有点明白了。“小王子说，有一朵花….我想,它已经把我驯服了….. “这是可能的。“狐狸说，“世界上什么样的事都可能看到…… “哦，这不是在地球上的事。“小王子说。 狐狸感到困惑而好奇。 “在另一个星球上?” “是的。” “那个星球上有猎人吗?” “没有。” 嗯，这真有意思。那有鸡吗?’ “没有。” “凡事都不能十全十美的。“狐狸叹息地说道。可是，狐狸又把话题拉回来： “我的生活很单调。我捉鸡。而人又捉我。所有的鸡全都一样,所有的人也全都一样。因此,我感到有些腻烦了。但是，如果你驯服了我，我的生活就会充满灿烂的太阳。我会辨认出一种与众不同的脚步声。其他的脚步声会使我躲藏到地下去,而你的脚步声却像动听的音乐一样把我召唤出洞穴。还有，你看，你看到那边的麦田没有?我不吃面包,麦子对我来说,一点用也没有。我对麦田无动于衷。这真使人扫兴。但是,你有着一头金黄色的头发。那么，一旦你驯服了我，就会十分美妙。麦子是金灿灿的,它会让我想起你。而且,我会喜欢那风吹麦浪的声音…. 狐狸冗默不语。久久地看着小王子。 请你…..服我吧!它说。 “我非常愿意 。“小王子回答说，“可我没有足够的时间。我还要去寻找朋友,还有许多东西要了解。” 只有被驯服了的东西。才会被了解。“狐狸说，人不会再有时间去了解任何东西的。他们去商人的商店里去购买现成的东西。但是,世界上还没有能购买朋友的商店,所以,人也就没有朋友。如果你想要一个朋友,那就驯服我吧！” “要驯服你，我必须要做什么呢?”小王子问。 “应当非常耐心。“狐狸回答道. “开始你就这样坐在草丛中,坐得离我稍微远一些。我用眼角看着你,你也不要说什么。语言是误会的根源。但是，每过一天，你就坐得离我更近一点…. 第二天，小王子又来了。 “最好还是在原来的那个时间来。狐狸说到，“比如说 ，你在下午四点来的，那么。从三点钟起,我就开始感到开心。随着时间一点点推移,我就会感到越来越开心。到了四点钟的时候,就会坐立不安。我就发现了快乐的价值。但是,如果你随便什么时候来，我就不知道在什么时候该准备好我的心情……必须遵守一定的仪式。” “仪式是什么?小王子问道。 “这也是一种已经被人忘却了的事。”狐狸说。“就是让某一天与其他日子不同,让某一时刻与其他时刻不同。比如说.我的那些猎人就有一种仪式。他们每星期四都要和村子里的姑娘们跳舞。所以,星期四就是一个非常美好的日子!我可以到葡萄园去散步。如果猎人们什么时候都跳舞，天天都一样，那么。我也就没有假日了。” 就这样,小王子驯服了狐狸。当他出发的时刻就快要来临的时候: “啊!你一定会哭的。“狐狸说。 “这是你自己的过错,小王子说.“我从来没有想过让你遭受痛苦，可你却让我驯服你….. 是这样的。狐狸说。 “但是。现在你就要哭了！“小王子说。 “那当然。”狐狸说。 “那么你什么好处也没得到。” “因为麦田的颜色，我还是得到了好处。“狐狸说。 然后。她又接着说。 再去看看那些玫瑰花吧。你一定会明白,你的那朵是世界上独一无二的玫瑰。然后你回来跟我告别时,我再送给你一个秘密。 于是。小王子又去看那些玫瑰。 “你们一点也不像我的那朵。你们现在还什么都不是呢!“小王子对它们说，“还没有人驯服过你们呢,你们也没有驯服过任何人。你们就像我第一眼看到狐狸那样,它那时只是和其他成干上万只狐狸一样,是只普通的狐狸。但是，我现在已经把它当成了我的朋友,这样,它现在就是世界上独一无二的了。 那些玫璃花听了显得非常尴尬。 “你们很美，但你们是空虚的。”小王子继续说，“没有人能为你们去死。当然，一个普遇的过路人会认为我的那朵玫瑰花和其他的玫瑰花一样。可是，她单独一朵就比你们全体的玫瑰重要，因为它是我浇灌的。因为它是我放在花罩中的。因为它是我用屏风保护起来的。我帮它清除了毛虫(除了留下两三只为了变蝴蝶而外)。因为我倾听过它的抱怨和自诩,甚至有时我聆听着它的沉默。因为它是我的玫瑰。 他又回到了狐狸身边。 “再见了。“小王子说道。 “再见。“狐狸说。“喏,这就是我的秘密。一个非常简单的秘密:只有用心才能看得清，事物的本质，用肉眼是看不见的。 “事物的本质,肉眼是看不见的。小王子重复着这句话，以便能把它牢记在心里。 “正因为你为你的玫瑰花费了时间,才使你的玫瑰变得如此重要。” “正因为我为我的收瑰花费了时间..小王子又重复着，确保让自己记住这些。 “人已经忘记了这个真理,“狐狸说,可是,你不应该忘记她。你要对你驯服过的一切东西负责到底。你要对你的玫瑰负责…. “我要对我的玫瑰…小王子又重复着,以便自己能记在心里。"},{"title":"矩阵03","date":"2020-06-21T10:00:17.000Z","url":"/2020/06/21/%E7%9F%A9%E9%98%B503/","tags":[["考研","/tags/%E8%80%83%E7%A0%94/"],["线性代数","/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"]],"categories":[[" ",""]],"content":"矩阵的逆定义 (1)定义 A,B是n阶方阵,E是n阶单位矩阵,若AB=BA= E,则称A是可逆矩阵,并称B是A的逆 矩阵,且逆矩阵是唯一的,记作A-‘. (2)A可逆的充分必要条件是|A|≠0.当|A|≠0时,A可逆,且 性质和重要公式设A,B是同阶可逆矩阵,则 用定义求逆矩阵的方法方法一 依定义,即求一个矩阵 B,使AB=E,则A可逆,且A-‘= B. 方法二 将A分解成若千个可逆矩阵乘积.因两个可逆矩阵的积仍是可逆矩阵,即若A= BC,其中， B,C均可逆,则A可逆,且 方法三 一些简单分块矩阵的逆.若A,B均是可逆方阵,则 伴随矩阵的定义伴随矩阵将行列式|A|的n2个元素的代数余子式按如下形式排成的矩阵称为A的伴随矩阵,记作A*,即 伴随的性质和公式 用伴随矩阵求逆矩阵的方法"},{"title":"反思","date":"2020-06-05T05:18:35.000Z","url":"/2020/06/05/%E5%8F%8D%E6%80%9D/","tags":[["小结","/tags/%E5%B0%8F%E7%BB%93/"]],"categories":[[" ",""]],"content":" 古语说：知耻而后勇;大意是 ，只有牢记耻辱，思考耻辱的原因，卧薪尝胆，时刻警醒，才能洗却耻辱，自立自强 我觉得这句话就符合当下的情况 写这篇文章的原因我想大概有两个 一是前几天，我妈得了一种病，左手手指抓不住东西，甚至连端碗都端不了，去医院看了，可能是神经方面的问题，开了药，这几天吃了好了一点；这件事让我突然意识到，父母真的在变老，不像以前了，时间在变，我也变了；以前觉得它们还在中年，不会有事，现在也在出现健康问题，这次也就是次预警；因为这样，我觉得我有一种责任，现在站出来，做为家庭的一员，让父母轻松一点；以前也有这种感觉，但是没有这么强烈 二呢就是因为最近的一些事，学习上的，生活上的；最近一段时间我在赶进度，准备考研，还要上课，加上考试，复习进度就一直受影响；基本上一天都不能完成计划的事情，到了第二天又拖到第三天，到后来就很抵触这个事情了，状态也不好，学也学不进去；我觉得以这种状态预期，会产生一个很糟的结果 现在主要的问题是畏难，事情多了以后，怕耽误复习时间，上专业课就不是是很认真，也没学透，做作业就很抵触； 解决这个的办法似乎并不是一钟办法，好像是一种心理上的变化；我现在已经不是一个男生了，我对自己的行为负责；以前是一种学生思维，觉得我应该把学校的布置做完，是被动的，而现在我才是主角；考研是我自己的选择，我对自己负责，什么行为导致了什么后果，这都是应当承受的；从什么时候起，我变的害怕失败从而怀疑自己的；我好像错了很远；平常笑话别人，作茧自缚，今天也轮到自己头上；所以，要培养自己的毅力，就从最普通的作业开始，不带抵触情绪，认真处理好它们 听其言，观其行；时间才能证明；希望我能引以为戒，不再徘徊"},{"title":"二重积分01","date":"2020-06-01T04:01:55.000Z","url":"/2020/06/01/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%8601/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"几何背景二重积分的几何意义可以参考定积分的几何意义 定积分 是求曲边梯形的面积 二重积分 表示曲顶柱体的体积 底面积（被积区域）乘以高（函数值） 不断累加得到体积 性质性质1(求区域面积) 其中A为D的面积 性质2(可积函数必有界) 当 f(x,y)在有界闭区域D上可积时,则f(x,y)在D上必有界、 性质3(积分的线性性质) 设 k1,k2为常数,则 性质4(积分的可加性) 当 f(x,y)在有界闭区域D上可积时,且D1UD2=D.D1∩D2.=∅,则 性质3和性质4一个是拆函数，一个是拆区域 性质5(积分的保号性) 当 f(x,y) g(x,y)在有 界闭区域D上可积时,若在D上f(x,y)≤g(x,y)，则有 特殊的有 可以理解为两个同底的柱体，一个比另一个高，体积就大 性质6(二重积分的估值定理) 设 M,m分别是f(x,y)在有界闭区域D上的最大值和最小值,A为D的面积，则有 性质7(二重积分的中值定理) 设函数 f(.r,y)在有界闭区域D上连续,A为D的面积,则在D上至少存在一点(ξ.η),使得 对称性普通对称性若积分区域是关于y轴对称，也就是关于字母x,则考察被积函数中x是否是奇函数还是偶函数，偶倍奇零 若现在积分区间是关于x轴对称，则考察字母y的关系 若现在积分区间关于原点对称，也就是关于x,y都是奇函数，看两个字母都可 轮换对称性若把上与y对调后,区域D不变(或区域D关于y=x对称),则 "},{"title":"小结4","date":"2020-05-31T13:31:12.000Z","url":"/2020/05/31/%E5%B0%8F%E7%BB%934/","tags":[["小结","/tags/%E5%B0%8F%E7%BB%93/"]],"categories":[[" ",""]],"content":"今天是五月的最后一天，离考研还有六个半月时间，学部组织了一场上岸学长学姐的经验分享会；感觉更有压力和争劲了，算算日子，就是两百天左右，学校还有课上，复习要跟上，希望剩下的这两百多天能充分利用好时间，好好学习 目前的进度 英语：一直在背单词，单词量差不多又五百左右，单词书到了第八单元；说真的，背单词刚开始是真难，坚持一段时间还可以，就适应了，好像也没有原来那么恐惧了，这时进步；但是也有忘记的问题，很严重，前面的一些单词需要经常复习才行，只是基本的识记，不会拼写，写作词汇没有很多；长难句没有怎么看，所以六月份的长难句要花时间准备 数学：高数上基本知识点过了一遍，下侧的考点比上册少很多，看到二重积分的位置，依然是做不到题或者速度很慢，问题很严重，我决定在整个六月好好把基础题相关的好好刷一刷，另外，要在六月份把线代看完，完成第一轮复习 下面做一下六月份的计划 六月份的重点依然是数学和英语；一个月前就想把数学第一轮完成，现在看哈哈哈，接下来六月份，数学的任务就是把剩下高数下和线代过完，完成第一轮复习，并且要加强题目练习；英语重点还是背单词和长难句，并且长难句是重点 六月依然是充满希望的一个月呢！ 另外，迷上了男神 链接: 外交部长王毅答记者问"},{"title":"显示原理","date":"2020-05-30T03:42:04.000Z","url":"/2020/05/30/%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86/","tags":[["嵌入式","/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"categories":[[" ",""]],"content":" 主要介绍两种显示技术，科普向 LCD OLED 都是基于三基色原理实现 绝大多数单色光也可以分解成RGB三种色光， 大多数的颜色可以通过RGB三色按照不同的比例合成产生 显示器就是由无数这样的像素点组成，只需要调节不同颜色的配比，就能显示不同颜色 夜晶显示器LCD Liquid Crystal DisplayLcd是多层结构，可以分为 背光层（Back-light）、液晶层（Liquid crystal）、颜色过滤层（Color filter） 在最底层有一层发光背板，发白光作为光原，背板的光有大部分损耗了 液晶层用来控制颜色的比例；液晶层在两成偏振膜之间，通过电压能够控制液晶的螺旋结构，从而改变光的偏振角度；LCD的缺点也源于此，黑的不够黑，无论怎么样也做不到完全阻止所有光线穿过，还会有少量光线穿过，所以lcd显示黑色会发灰 过滤层用来控制色彩，滤光层本身不发光，是透光的，过滤层控制进光量就能显示不同颜色 lcd屏幕优点有有成熟的技术支持，各种优化全面 有机发光半导体OLED Organic Light-emitting DiodeOLED与Lcd最大不同就是没有发光背板，它是有机发光半导体自发光，所以纯黑就是不发光，进而对比度高于lcd OLED的主要结构是有机发光层、玻璃基板 在玻璃基板上制作一层几十纳米厚的有机发光材料作发光层，在电极注入电子的作用下发光。由电极注入的电子和空穴在发光层中复合形成处于束缚能级的电子空穴对即激子，激子辐射退激发发出光子，产生可见光。 原理介绍详见容易视听的回答 - OLED缺点也很多，一是成本，制作要求对环境要求很高；二是会有烧屏现象且不可逆，lcd也有烧屏现象，但原理不同且可逆"},{"title":"多元函数微分学3","date":"2020-05-27T10:39:36.000Z","url":"/2020/05/27/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A63/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"多元函数的微分法则链式求导规则先写复合结构图，后面有分支就写偏微分，后面只有一个就微分 隐函数存在定理隐函数存在定理1 隐函数存在定理2 多元函数的极值与最值极大值概念若存在（x0，y0）的某个邻域，使得在该邻域任意一点（x，y） 均有f（x，y）≤f（x0，y0）成立 则称（x0，y0）为f（x，y）的极大值点 无条件极值定理1 (必要条件)函数z= f(x,y)在点(xo,yo)存在偏导数，且在该点取得极值，则有 f’x(x0,Yo)=0，f’y(xo,Yo)=0 注：该定理说明偏导数存在并且不等于0的点一定不是极值 1)几何意义:极值点处的切平面平行于xoy平面; 2)使一阶偏导数同时为零的点，称为函数的驻点. 定理2 (充分条件)若函数z= f(x,y)在点(xo,yo)的的某邻域内具有- -阶和二阶连续偏导数，且 注:如果AC- B2=0，只能用定义判定是否是极值 推广 如果三元函数u= f(x,y,z)在点P(xo,yo,zo)具有偏导数，则它在P(xo,yo,zo )有极值的必要条件为 fx(xo,yo,zo)= 0 fy(xo,yo,zo)=0 fz(xo,yo,zo)= 0"},{"title":"测试方法","date":"2020-05-26T11:04:57.000Z","url":"/2020/05/26/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/","tags":[["软件测试","/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"]],"categories":[[" ",""]],"content":"代码要求 可运行 易于维护 灵活性 可靠性 静态测试(static testing)通过手工检查(评审)或自动化工具分析(静态分析)的方式对代或其他的项目文档进行检查直接发现缺陷(引起失效的原因)发现的典型缺陷:与标准之间的偏差、需求内的错误、设计错误、可维护性不足和错误接口规格说明等等 步骤互查(Peer Review) 走查(Walk Through) 评审( Inspection ) 如果没有需求文档就列一些常见问题形成一个检查列表 数据结构测试 误解或用错了算符优先级 混合类型运算 变量初值错 精度不够 表达式符号错 其他 模块接口测试 输入的实际参数与形式参数是否一致(个数、属性、量纲) 调用其他模块的实际参数与被调模块的形参是否一致。 个数、属性、量纲 全程变量的定义在各模块是否一致。 外部输入、输出 文件、缓冲区、错误处理 其它 临界数据处理的正确性测试 普通合法数据的处理。 普通非法数据的处理。 边界值内合法边界数据的处理。 边界值外非法边界数据的处理。 其它 异常处理测试 输出的出错信息难以理解 记录的错误与实际不相符 异常处理不当 未提供足够的定位出错的信息 其它 动态测试(dynamic testing)发现的典型缺陷:软件运行过测试软件 发现软件失效(缺陷的外部表现) 发现的典型缺陷:软件运行过程中与规格说明、用户需求之间的偏差 代码检查工具 Checkstyle:静态语法检查 Findbugs:静态逻辑bug检查 SourceMonitor:代码质量自动检查 CheckstyleCheckStyle是一款代码格式检查工具，关注代码格式带来的缺陷、风险和问题。 根据设置好的编码规则来检查代码(定制化的) 规则可以触发通知(notification),警告(warning)和错误(error) 只做检查，不修改代码 FindbugsFindbugs是一个静态分析工具，检查类或JAR文件，将字节码与一组缺陷模式进行对比以发现可能的问题。 发现的问题大部分都是在Runtime过程中，会造成程序异常、错误的 可以联系class所在package的上下文，对代码进行穿透检查，对隐藏的比较深层次的逻辑错误、资源操作问题等进行报警 更加专注于逻辑风险、错误，例如:可能发生的无限循环，效率低下的数据结构访问等 SourceMonitorSourceMonitor可以为多种编程语言(比如C/C++ ,JAVA)的源代码文件测试代码数量和性能，最终结果可描绘成图、输出打印。 度量、记录和显示代码质量指标:代码行数、注释行数、分支比例、注释比例、类定义个数、方法个数/类、平均语句数/方法、最大复杂度、最大调用深度、平均复杂度、函数个数。 提取代码复杂度信息，为代码重构提供指导 提示代码安全隐患，将问题解决在开发阶段 提高程序员代码质量和工作效率 "},{"title":"多元函数微分学2","date":"2020-05-26T02:49:28.000Z","url":"/2020/05/26/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A62/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"可微对于一元函数的微分 若函数在x0邻域内有定义，x+△x在x0邻域内有定义，则增量△y=f(x+△x)-f(x) 若存在一个常数A，使得△y=A△x+o(x) （o(x)为高阶无穷小），则称函数在x0可微 可微的本质是用简单的线性增量代替复杂的△y，并可以忽略其中的误差 那对于多元函数，可微怎么定义？ 以矩形面积为例，设矩形长宽xy，面积s=xy，这时给长宽分别加上△x，△y 则增量为 △s=(x+△x) (y+△y) - xy =x△y+y△x+△x△y 此时x△y+y△x是△s的主要部分，固有定义 定义如果z=f(x,y)在点(x,y)的全增量△z=f(x+△x,y+△y) -f(x,y)可以表示成 △z=A△x+B△y+o(ρ) 其中ρ是根号下△x方+△y方，AB是△x△y无关，与xy有关 则称A△x+B△y为z=f(x,y)在点(x,y)的全微分，记作dz 判断可微步骤1.写全增量△z=f(x+△x,y+△y) -f(x,y) 2.写线性增量A△x+B△y 3.做极限 若该极限为0，则可微，否则不可微 ρ的具体含义一元函数在x0点的微分为： dy=f(x0)’dx 其中lim△x-&gt;0 △y/dy=1，△y是dy的等价无穷小 设二元函数z=f(P)的定义域为D，P0(xo,yo)的某邻域内有定义，则函数在点P0的微分为： dz=f’(P0)ρ (ρ=|P0P|=√[(△x)²+(△y)²]) 注：几何上的解释为切平面内一条过P0P的直线。 这样写把dz=f’(P0)ρ 看做是一元函数的微分，同理limρ-&gt;0 △z/dz=1 所以△z=dz+o(dz)=dz+o(f’(p0)ρ)=dz+o(ρ) 再把dz=∂z/∂xdx+∂z/∂ydy的全微分带入得 △z=∂z/∂xdx+∂z/∂ydy+o(ρ) （ρ=√[(△x)²+(△y)²]） 参考 ρ 具体意义 如何通俗理解全微分 偏导数连续性 类似一元函数的导数连续性 步骤1.定义法求f‘x(x0,y0),f‘y(x0,y0) 2.公式法求f‘x(x,y),f‘y(x,y) 3.检验极限是否成立 如成立，则z=f(x,y)在点(x,y)的偏导数是连续的 "},{"title":"单元测试","date":"2020-05-22T10:25:14.000Z","url":"/2020/05/22/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","tags":[["软件测试","/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"]],"categories":[[" ",""]],"content":"单元测试（Unit Testing）又叫组件测试，模块测试，是针对程序式设计中最小的单位进行正确性检验的测试 目标 验证代码的功能和逻辑是否正确 平常写代码时，写print查看是否输出正确，属于调试，是解决错误，开发人员做；测试主要是发现错误，测试人员做； 如何测试代码评价标准：代码覆盖率步骤 1.转换流程图 2.分析流程图 3.生成测试用例 测试用例：一组测试输入，执行条件和结果 测试方法：白盒测试（结构化测试） 可以看到代码内容，考虑代码细节 语句覆盖 被执行的语句数量/总的语句数量 分支/判定覆盖 确保每个分支分到了结果，即保证每个判定取true和false至少一次 条件覆盖 确保每个条件得到了结果，不能保证每个判断分支都覆盖 条件组合覆盖 每个判定的所有可能条件取值组合至少执行一次 黑盒测试 看不到代码，检测功能"},{"title":"多元函数微分学01","date":"2020-05-22T08:07:31.000Z","url":"/2020/05/22/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":" 基本概念 M0的δ邻域 在平面上有一点M0， δ &gt;0,以M0为圆心， δ 为半径的圆的内部称为M0的 δ 邻域 给定平面内一点集E，对应有几个概念，内点，边界点，外点 聚点 闭区域的内点和边界点，开区域的内点和不属于它的边界点 极限设二元函数 f(P)= f(x,y)的定义域为D，Po(xo,Yo)是D的聚点，如果存在常数A，对于任意给定的正数ε，总存在正数δ，使得点Po∈定义域∩Po去心邻域时，都有|f(x,y)-A|&lt;ε 则称A为f(x,y)当 (x,y)-&gt;(xo,Yo)时的极限 为什么要属于定义域∩Po去心邻域，因为只看有定义的路径，若极限存在且唯一，则极限存在 连续 偏导数 二元函数上的点到聚点变换，如果直接变换，xy都在变换，这时可以先让y不动，变x，再让x不懂，变y，此时，二元就退化为一元，由复杂到简单;由于此时只研究了函数在某一个方向上的变化率，固称为偏导数 偏导数的定义 对应导数的定义，可以写出对应偏导数定义 设函数 z= f(x,y)在点(xo,yo) 的某一邻域内有定义，当y固定在yo而x在xo处有增量∆x时，相应地函数有增量 f(xo+∆x,yo)-f(xo,yo) 在点(xo,Yo)的邻域内有定义，若 存在，则称此极限为函数 在点 (xo,Yo) 处对x的偏导数 求x的偏导就视y为常数 偏导数的几何定义设Mo（xo,yo,f(xo,yo)） 为曲面 z= f(x,y)上一点，过Mo做平面y=yo， 截得曲面f(x,y)上的一条曲线f(x,yo)，此曲线在Mo处的切线斜率就是偏导数 如果一元函数在某点具有导数，则它在该点必定连续 但对于多元函数来说，即使各偏导数在某点都存在，也不能保证函数在该点连续 这是因为各偏导数存在**只能保证点P沿着平行于坐标轴的方向趋于Po时，f(P)趋于f(Po)**，不能保证P按任意方向趋于Po时，f(P)趋于f(Po) 高阶偏导数如果函数z= f(x,y)在定义域D内的偏导数仍有偏导数，则它们的偏导数称为高阶偏导数"},{"title":"积分等式与积分不等式","date":"2020-05-13T08:13:06.000Z","url":"/2020/05/13/%E7%A7%AF%E5%88%86%E7%AD%89%E5%BC%8F%E4%B8%8E%E7%A7%AF%E5%88%86%E4%B8%8D%E7%AD%89%E5%BC%8F/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"积分等式 中值定理 推广的积分中值定理 夹逼准则 此方法的信号就是极限后面有积分 注意：下面这题必须按顺序计算，先算积分再取极限，不能交换，交换需给出严格证明相等才可交换 积分法 积分再现法 积分不等式 函数单调性 拉格朗日中值定理 信号：一阶可导 泰勒公式 信号：二阶可导 积分法 信号：一个抽象函数和一个具体函数 "},{"title":"Android登录实例","date":"2020-05-11T09:17:56.000Z","url":"/2020/05/11/Android%E7%99%BB%E5%BD%95%E5%AE%9E%E4%BE%8B/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":"最近实现了一个极简的app登录功能，验证身份是通过向http服务器传url参数实现的 这次写代码，也并不顺利，经过不断尝试修改代码，最后才完成 代码实现的功能极其简陋，我觉得以后那天再回来看这篇文章的代码一定会被鞭尸 我还是想记录下，这种不断试错的精神，我认为是成为一个好的开发者的品质，需要发扬 MainActivity RegisterActivity node服务器上的监听代码 功能 实现登录功能，输入登录用户名和密码，当输入用户名或密码为空时，跳出提示，账号或密码不为空，前端就终止了下一步访问接口，防止用户误点 如果登录的账号密码和数据库的密码不匹配，就会提示出错 当输入正确的用户名和密码后，跳转到正常主页面 若注册时输入的密码不一致，会提示不一致 若注册的账号，服务器数据库中没有，则添加数据，跳转到组页面，注册成功 问题 问题呢，很多，比如安全的问题，密码是绝对不能以明文的方式出现在url中的，再不济写个通过post传递，都要好；还有代码复用的问题，不够简洁；以后肯定会被当成垃圾代码 界面 "},{"title":"MyBatis入门","date":"2020-05-11T07:54:10.000Z","url":"/2020/05/11/MyBatis/","tags":[["java","/tags/java/"]],"categories":[[" ",""]],"content":" MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 来源MyBatis MyBatis的主要思想是将程序中的SQL写到配置文件中配置，运用了ORM技术，通过javabean对象去实现增删改查，从而简化开发难度 ORM ORM（Object/Relational Mapping）对象关系映射，是一种数据持久化技术； 简单的说就是将关系型数据库映射成对象 表映射类 行映射对象（实例） 字段映射对象的属性 框架流程 图片来源MyBatis 简介 配置mybatis-config.xml 1.首先要配置数据库的连接信息，比如用户名密码，地址端口号 2.配置sql映射文件 创建会话工厂 SqlSessionFactory 由会话工厂创建会话会话对象 SqlSession ，调用sql语句和参数 执行 SqlSession通过Executor执行器接口操作数据库 返回结果 ResultSetHandler 处理查询结果"},{"title":"Handler","date":"2020-05-07T09:03:05.000Z","url":"/2020/05/07/Handler/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" 安卓的主线程不能搞耗时操作，子线程不能更新ui ;如果子线程要改变ui，就要通知主线程去改， Handler就是这种传递消息的机制 Handler对象handler： 负责 Message 的发送及处理。主要向消息池发送各种消息事件（Handler.sendMessage()）和处理相应消息事件（Handler.handleMessage()），按照先进先出执行，内部使用的是单链表的结构。 Message：需要被传递的消息 MessageQueue：负责消息的存储与管理，负责管理由 Handler 发送过来的 Message。读取会自动删除消息，单链表维护，插入和删除上有优势。在其 next()方法中会无限循环，不断判断是否有消息，有就返回这条消息并移除 Looper：负责关联线程以及消息的分发，在该线程下从 MessageQueue 获取 Message，分发给Handler,Looper 创建的时候会创建一个MessageQueue，调用 loop()方法的时候消息循环开始，其中会不断调用 messageQueue 的 next()方法，当有消息就处理，否则阻塞在 messageQueue 的next()方法中。当 Looper 的 quit()被调用的时候会调用messageQueue 的 quit()，此时 next()会返回 null，然后 loop()方法也就跟着退出 实现流程 图片来源Android 异步通信：图文详解Handler机制工作原理 "},{"title":"安卓获取图片示例","date":"2020-05-06T03:46:12.000Z","url":"/2020/05/06/%E5%AE%89%E5%8D%93%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E7%A4%BA%E4%BE%8B/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" 模拟获取图片的过程 注意添加网络访问权限 样式 Activity 结果 "},{"title":"Service服务","date":"2020-05-05T02:42:22.000Z","url":"/2020/05/05/Service%E6%9C%8D%E5%8A%A1/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" 服务是安卓四大组件之一，能够长期运行在后台，且不需要提供用户界面；服务的状态与开启者没有关系 服务的创建 startService() 直接开启 通过startService()启动，需要调stopService()才能停止 bindService () 绑定开启 通过bindService()绑定，需要与unbindService()解绑后，服务才被销毁 官方解释 服务的整个生命周期从调用 onCreate() 开始起，到 onDestroy() 返回时结束。与 Activity 类似，服务也在 onCreate() 中完成初始设置，并在 onDestroy() 中释放所有剩余资源。例如，音乐播放服务可以在 onCreate() 中创建用于播放音乐的线程，然后在 onDestroy() 中停止该线程。 无论服务是通过 startService() 还是 bindService() 创建，都会为所有服务调用 onCreate() 和 onDestroy() 方法。 服务的有效生命周期从调用 onStartCommand() 或 onBind() 方法开始。每种方法均有 Intent 对象，该对象分别传递到 startService() 或 bindService()。 对于启动服务，有效生命周期与整个生命周期同时结束（即便是在 onStartCommand() 返回之后，服务仍然处于活动状态）。对于绑定服务，有效生命周期在 onUnbind() 返回时结束。 服务的生命周期有五种方法 onCreate()创建 onStartCommand() 开始 onDestroy()销毁 onBind() 绑定 onUnbind() 解绑 三种状态 启动 startService() 启动服务，处于“启动”状态，启动后不管启动服务的组件是否销毁，服务依然运行 绑定 bindService() 绑定服务，处于“绑定”状态，服务只会在组件与其绑定时运行 启动且绑定调用**onStartCommand()**和 **onBind()**，处于“启动且绑定”状态 1.在整个生命周期内，只有onstartCommand()**能被多次调用,绑定和解绑都只能调用一次 2.绑定后没有解绑，无法使用stopService()将其停止 3.如果已经onCreate()，那么startService()将只调用startCommand() 4.如果是以bindService开启，那么使用unbindService时就会自动调用**onDestroy销毁 服务的通讯 服务的必须以绑定服务形式才能通讯 本地服务通讯：应用内的通讯 远程服务通讯：应用之间的通讯 服务例子 模拟两种服务 样式 Activity 服务类 manifest 结果 "},{"title":"安卓嵌套网页示例","date":"2020-05-05T02:41:21.000Z","url":"/2020/05/05/%E5%AE%89%E5%8D%93%E5%B5%8C%E5%A5%97%E7%BD%91%E9%A1%B5%E7%A4%BA%E4%BE%8B/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" 注意配置网络访问权限 从Android 9.0（API级别28）开始，默认情况下禁用明文支持，因此http的url均无法在webview中加载 在application中添加 android:usesCleartextTraffic=&quot;true&quot; 样式 Activity manifest 结果 "},{"title":"广播示例","date":"2020-05-04T08:16:12.000Z","url":"/2020/05/04/%E5%B9%BF%E6%92%AD%E7%A4%BA%E4%BE%8B/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" 通过广播实现对特定号码的拦截，写两个按钮，一个是正常拨号，一个是拨号后进行拦截 注意要在配置文件内添加权限 样式 Activity 接收者类 拦截类 manifest 结果 "},{"title":"BroadcastReceiver","date":"2020-05-04T08:06:51.000Z","url":"/2020/05/04/BroadcastReceiver/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" BroadcastReceiver广播，是一个全局的监听器，用于应用程序之间的消息传递 之所以是全局，是因为 BroadcastReceiver有自己的进程，只要存在与之匹配的Broadcast被以Intent的形式发送出来，BroadcastReceiver就会被激活 每次发布Broadcast的时候，系统都会创建对应的BroadcastReceiver广播接收者实例，并自动触发onReceive()方法，onReceive()方法执行完成之后，BroadcastReceiver的实例就会被销毁 如果在五秒钟内 onReceive()方法不能 执行完， 系统就会弹出无响应框，所以onReceive()方法里面尽量写耗时短的 广播的角色模型中有3个角色：广播接收者，广播发布者和消息中心 广播接收者在消息中心注册，广播发布者的广播会发到消息中心，如果在消息中心找到符合发布者要求的接收者的注册信息，就通知接收者，接收者调用onReceive()方法 广播发布者不关心广播能不能被接到，也不关心广播什么时候被接到 广播的分类 有序广播： 同步执行 ，发出一个广播之后，由匹配的BroadcastReceiver优先级高的先接收， 可以把结果传入下一个接收器中，也可以终止Broadcast的传播 ，所以可以进行拦截 无序广播： 完全异步，发出一个广播之后，理论上，所有的与之匹配的BroadcastReceiver都同时接收到Broadcast，所以不能被拦截 一般系统发送出来的Broadcast均是有序广播，所以可以通过优先级的控制 发送广播的方法发送方法是对发送者来说的，发送出去的广播只有两种可能，被接收和未被接收 如果有满足接收条件（注册过的）有如下方法 sendBroadcast()：发送普通广播 sendOrderedBroadcast()：发送有序广播 还有一种当发出去的广播，没有接收者注册，是不是就没用了？其实不是，广播是一定有接收者接收的，否则广播就没有意义，没有接收者只是暂时的；我们希望的是，如果遇到这种情况，就把广播存起来，当有接收者来注册时，再发给他，就有了如下方法 sendStickyBroadcast() 创建广播接收者创建继承自BroadcastReceiver类定义广播接收者 重写 onReceive 来响应广播 注册 :如果是静态注册在AndroidManifest.xml中注册，如果在动态注册就在代码中 静态注册 android:name指定注册的BroadcastReceiver对象 android:priority设置BroadcastReceiver的优先级 一般还会在Intent-filter/指定 action 表示这个Intent此次操作的动作 category 为Action增加额外的附加信息 动态注册 Content.registerReceiver(BroadcastReceiver receiver, IntentFilter filter) 在代码中进行注册 receiver：注册的BroadcastReceiver对象 filter： Intent 过滤器 Content.unregisterReceiver(BroadcastReceiver receiver)进行注销 receiver：注册的BroadcastReceiver对象 下面介绍一下以广播作用域分类的广播 本地广播LocalBroadcastManager 本地广播只能够在应用程序内部进行传递，并且广播接收器也只能接收来自本地应用程序发出的广播，相当于把范围限制在了app范围内 LocalBroadcastManager.getInstance(Context context) context：上下文 自定义广播权限只有符合自定义权限要求的广播才接收处理 详见自定义广播 "},{"title":"ListView示例","date":"2020-05-04T06:53:03.000Z","url":"/2020/05/04/ListView%E7%A4%BA%E4%BE%8B/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" 用listview写一个列表，自定义item样式 遇到的问题，一定要给item的文本设置字体颜色，第一次没设，一直以为程序有bug，结果字体是白色的，好好的被折腾了一番；另外图片的导入也需要注意，有几次不能展示，很奇怪，问题没法复现，多次重新编译后成功，不知道为什么 样式文件 Item Activity 界面 "},{"title":"矩阵02","date":"2020-05-03T14:17:57.000Z","url":"/2020/05/03/%E7%9F%A9%E9%98%B502/","tags":[["考研","/tags/%E8%80%83%E7%A0%94/"],["线性代数","/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"]],"categories":[[" ",""]],"content":"向量内积与正交 内积定义 (α,β) = ||α|| ||β|| cosθ ||α||称为模，等于自己的分量的平方和开根号 正交定义：内积为0，称向量α，β是正交向量 标准正交向量组 标准正交化 正交化 证明 单位化 矩阵的幂 方阵乘积的行列式 |AB|=|A||B| 重要矩阵零矩阵 每个元素均为0的矩阵 单位矩阵 主对角线全是1，其余元素全为0的n阶方阵 数乘矩阵 数k和单位矩阵的乘积 对角矩阵 非对角元素均为0 上(下)三角矩阵 主对角线以下都是零的方阵称为上三角矩阵 对称矩阵 转置之后等于本身的矩阵 反对称矩阵 正交矩阵 分块矩阵 将一个矩阵用若干条横线和竖线分成许多个小矩阵，将每个小矩阵称为这个矩阵的子块，以子块为元素的形式上的矩阵称为分块矩阵 "},{"title":"SQLite增删改查示例","date":"2020-05-03T08:00:58.000Z","url":"/2020/05/03/SQLite%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%A4%BA%E4%BE%8B/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" 用DatabaseHelper重写onCreate方法创建数据库db1.db ,用方法openOrCreateDatabase创建数据库db2.db,分别用SQLiteDatabase封装好的方法和sql语句实现增删改查 我写代码时遇到了很多问题，openOrCreateDatabase注意一定要写正确路径，写之前不要忘记初始化按钮；最后我发现此代码还有bug，此代码只是展示如何进行增删改擦，所以语句都写死了，只能运行一次，如果想再次运行，必须把前面建好的库删掉，重新按顺序运行；下面是代码部分 样式文件 Activity DatabaseHelper构造类 界面 点击创建 databases 目录下有两个文件 *.db 是我们创建的数据库 *.db-journal 是为了能让数据库支持事务而产生的临时的日志文件 点击添加 点击删除 点击更新 点击查询 "},{"title":"listView控件","date":"2020-05-03T04:08:41.000Z","url":"/2020/05/03/listView%E6%8E%A7%E4%BB%B6/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" ListView 是 一种列表显示控件;继承自抽象类 AdapterView 示例 ListView由很多**item(条目)**组成，这个item需要单独使用布局文件定义 使用listView需要对数据做适配，适配器就是数据和视图的桥梁；常用适配器有 Basedapter ArrayAdapter SimpleAdapter 当需要显示数据的时候，ListView 会从适配器（Adapter）中取出数据，然后来加载数据 , ListView 负责以列表的形式向我们展示 Adapter 提供的内容 来源：ListView详细介绍与使用 Basedapter基本适配器 方法 作用 public int getCount() 得到条目的数目，比如格子的数量 public Object getItem(int position) 根据位置获得该位置的对象 public long getItemId(int position) 根据位置获取条目的id public View getView(int position, View convertView, ViewGroup parent) 得到一个item的视图 public View getView(int position, View convertView, ViewGroup parent) position：item的位置 convertView：旧视图 parent：父视图 SimpleAdapterSimpleAdapter继承自Basedapter，对上面的四个抽象方法进行了封装 public SimpleAdapter (Context context, List&lt;? extends Map&lt;String, ?&gt;&gt; data, int resource, String[] from, int[] to) context：上下文 data： 数据集合，data中的每一项对应listView中每一项数据 resource：item布局文件的资源ID from：Map集合中的key to：item布局对应控件 ArrayAdapterSimpleAdapter继承自Basedapter，通常用于TextView SimpleAdapter常见的两个构造方法 ```javapublic ArrayAdapter(Context context,int resource, int textViewResourceId, T[] objects) context：上下文 resource：item布局文件的资源ID textViewResourceId：item布局相对应的TextView的ID T[] objects：需要适配的数据数组 List objects：需要适配的LIst类型数据 "},{"title":"button的写法","date":"2020-05-02T14:52:48.000Z","url":"/2020/05/02/button%E7%9A%84%E5%86%99%E6%B3%95/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" 转载于  四种onClick单击事件 XML文件 第一种、匿名内部类： 第二种、自定义单击事件监听类： 第三种、Activity继承View.OnClickListener，由Activity实现OnClick(View view)方法，在OnClick(View view)方法中用switch-case对不同id代表的button进行相应的处理： 第四种、在XML文件中显示指定按钮的onClick属性，这样点击按钮时会利用反射的方式调用对应Activity中的click()方法： 总结：第四种写法整个代码中都不用声明button就可以实现button的单击事件。但通常不推荐这样使用，第三种方法是onClick最佳的的使用方式。按钮少的时候用匿名内部类会比较快，比如写demo测试的时候。"},{"title":"SQlite数据库","date":"2020-05-02T06:54:15.000Z","url":"/2020/05/02/SQlite%E6%95%B0%E6%8D%AE%E5%BA%93/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":"简介 SQLite是一款轻型的数据库，关系型数据库；适用于嵌入式，占用资源非常低 支持 ACID，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability） 支持五种数据类型 NULL: 表示该值为NULL值 INTEGER: 无符号整型值 REAL: 浮点值 TEXT: 文本字符串，存储使用的编码方式为UTF-8、UTF-16BE、UTF-16LE BLOB: 存储Blob数据，该类型数据和输入数据完全相同 其他类型的数据会转换成五种基本数据类型存储 SQLite数据库文件存放路径/data/data//databases/ SDK提供的常用接口 接口 功能 SQLiteOpenHelper 抽象类，用于创建数据库和版本更新 SQLiteDatabase 数据库访问类，用于增删改查 Cursor 游标接口，作为返回值 CRUD：其中C代表添加（Create），R代表查询（Retrieve），U代表更新（Update），D代表删除（Delete） 数据库的创建 创建 SQLite 数据库的方法是实现 SQLiteOpenHelper 接口的子类，并且重写 onCreate() 方法，在该方法中执行用于创建 SQLite 数据库的命令 核心类(必要) DatabaseHelper(Context context, String name, CursorFactory cursorFactory, int version) 构造函数 context：上下文环境（例如一个 Activity） name：数据库名 cursorFactory：可选的游标工厂（通常是 Null） version：版本号 onCreate（SQLiteDatabase db）初始化数据 onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)数据库版本操作 db：一个SQLiteDatabase对象 oldVersion：旧版本号 newVersion：新版本号 关键代码 获取数据库对象 getReadableDatabase()： 返回一个可写数据库，返回一个SQLiteDatabase对象，通过这个对象进行数据库读写操作 getWritableleDatabase() ： 返回一个可读数据库，返回一个SQLiteDatabase对象，通过这个对象进行数据库写入或读写操作 SQLite 数据库操作 SQLiteDatabase 对象提供了对数据库进行操作的一系列方法 打开或创建数据库 openOrCreateDatabase (Stringpath,SQLiteDatabase.CursorFactory factory) Stringpath 数据库的路径 SQLiteDatabase.CursorFactory factory 游标 详细可见链接，详细介绍了三种创建方法，以及之间的联系 增加 insert (String table,String nullColumnHack,ContentValues values) table：表名 nullColumnHack： 空列的默认值 values： ContentValues封装的键值对组成的Map，key代表列名，value代表该列要插入的值 删除 delete (String table,String whereClause,String[] whereArgs) table：表名 whereClause：删除条件 whereArgs[]：条件值数组 修改 update (String table,ContentValues values,String whereClause,String[] whereArgs) table：表名 values： ContentValues 类型的键值对 whereClause：修改条件 whereArgs[]：修改的条件值数组 查询 table：表名 columns[]：查询的列所有名称集 selection：WHERE之后的条件语句，可以使用占位符 selectionArgs：条件语句的参数数组 groupBy：指定分组的列名 having：指定分组条件,配合groupBy使用 orderBy：y指定排序的列名 limit：指定分页参数 distinct：指定“true”或“false”表示要不要过滤重复值 Cursor：返回值，相当于结果集ResultSet 查询完会返回一个Cursor对象，代表数据集的游标 方法名称 方法描述 close() 关闭游标，释放资源 copyStringToBuffer(int columnlndex, CharArrayBuffer buffer) 在缓冲区中检索请求的列的文本，并将其存储 getColumnCount() 返回所有列的总数 getColumnIndex( String columnName) 返回指定列的名称，如果不存在，就返回-1 getColumnIndexOrThrow(String columnN ame) 从零开始返回指定列的名称，如果不存在，将抛出异常 getColumnName(int columnlndex) 从给定的索引返回列名 getColumnNames() 返回一个字符串数组的列名 getCount() 返回Cursor中的行数 moveToFirst() 移动光标到第一行 moveToLast() 移动光标到最后一行 moveToNext() 移动光标到下一行 moveToPosition(int position) 移动光标到一个绝对的位置 moveToPreviousQ 移动光标到上一行 SQL 以上操作也可以通过直接执行sql语句实现 execSQL (String sql) 关闭 close()"},{"title":"SharedPreferences","date":"2020-05-02T04:15:17.000Z","url":"/2020/05/02/SharedPreferences/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" SharedPreferences：一个轻量级的存储类，适合存储少量数据如应用配置信息 SharedPreferences存储的数据是以键值对（key,value ）存储的 存放在/data/data//shared_prefs目录下 value 数据类型有：int、boolean、float、long、String、StringSet SharedPreferences使用方法读操作核心类 Activity类的getSharedPreferences(String name,int mode)得到SharedPreferences对象 name：保存键值对的文件名 mode：操作模式 SharedPreferences对象的getXxx(String key,Xxx value)获得键值对 关键代码 写操作核心类 Activity类的getSharedPreferences(String name,int mode)得到SharedPreferences对象 name：保存键值对的文件名 mode：操作模式 SharedPreferences的edit()获得SharedPreferences.edit()对象 SharedPreferences.edit().putXxx(String key,Xxx value)写入键值对 SharedPreferences.edit().commit()保存键值对 关键代码 例子 做一个仿照qq的登录页面，输入用户名密码，通过SharedPreferences实现存储输入信息，并能读取存储的的信息；这个demon实现的功能很简单，只是实现了基本的存取数据，如果在多个数据中取某个特定数据，还需要添加功能 样式文件 Activity manifest配置 结果 可以看到路径下生成了对应的文件 文件显示正确 "},{"title":"矩阵01","date":"2020-05-01T12:36:31.000Z","url":"/2020/05/01/%E7%9F%A9%E9%98%B5/","tags":[["考研","/tags/%E8%80%83%E7%A0%94/"],["线性代数","/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"]],"categories":[[" ",""]],"content":"矩阵的定义和基本运算定义 矩阵由若干行向量拼成 矩阵不能运算，但向量之间有关系，这种关系称为矩阵的秩 mxn矩阵是一个由m行（row）n列（column）元素排列成的矩形阵列 矩阵的秩最高阶非零子式的阶数 r(Anxn)=n &lt;-&gt;|A|≠0 &lt;-&gt; A可逆 矩阵的秩本质就是组成该矩阵的线性无关向量个数 同型矩阵：两个矩阵行列数分别对应相同 基本运算相等：同型矩阵且所有对应元素相同 加法：同型矩阵可加 数乘矩阵：kA=Ak（A的每个元素都乘与k） 注意：|kA|=k^n|A|≠k|A| 线性运算： 加减法：要求同型矩阵 交换律：A+B=B+A 结合律：(A+B)+C=A+(B+C) 分配律：k(A+B)=kA+kB 数和数乘矩阵的结合律：k(lA)=(kl)A=l(kA) 矩阵乘法：对应行乘与对应列（所以要求前面的行数和后面列数相同） A mxs B sxn = C mxn 首尾相接 乘法结合律 乘法分配律 数和数乘矩阵乘积的结合律 乘法矩阵一般没有交换律：AB不一定等于BA 转置矩阵：将行列互换 "},{"title":"Android数据存储","date":"2020-04-30T22:44:01.000Z","url":"/2020/05/01/Android%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":"五种存储方式 文件存储：通过io流的形式，类似java的io流文件存储 SharedPreferences：Android提供的一些简单配置信息的机制 SQLite数据库存储：Android自带的轻量级数据库，支持sql ContentProvider：Android四大组件，可以把数据共享给其他应用 网络存储：通过网络空间 文件存储分为内部存储和外部存储 默认路径 性质 内部存储 /data/data//files/目录 在程序内，程序卸载，存储文件就会删除 外部存储 通常mnt/sdcard目录下 外部设备上比如sd卡，程序卸载，存储文件不会删除 内部存储实现读操作(即读取)核心类 openFileInput(String name)读取文件，打开指定输出流 name：打开文件名，不包含路径分隔符 返回类型：FileInputStream 关键代码 写操作(即存储)核心类 openFileOutputStream(String name,int mode)保存文件，打开指定输出流 name：打开文件名，不包含路径分隔符 mode：操作模式 返回类型：FileOutputStream 关键代码 文件操作模式 模式 操作（mode取值） MODE_PRIVATE 默认操作模式，代表私有数据，只能应用本身访问，写入内容会被覆盖，就是说永远保存的是最后内容 MODE_APPEND 检查文件是否存在，不存在就创建文件，否则追加内容 外部存储实现 外部设备需要确认是否可用,调用getExternalStorageState() 外部设备可用且有读写权限才能进行操作做 文件存储的例子样式文件 Activity manifest配置 注意：由于安卓的安全策略，需要添加读写权限 结果 点击保存后会看到应用目录内新建了一个txt data/data/对应包内/· 打开txt可以看到添加的字符串 点击保存后会看到sd目录内新建了一个txt(不同手机可能会不同) sdcard/· "},{"title":"activity跳转例子","date":"2020-04-30T12:16:43.000Z","url":"/2020/04/30/activity%E8%B7%B3%E8%BD%AC%E4%BE%8B%E5%AD%90/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":"纯跳转代码，不包含逻辑 文件目录 两个样式文件 activity_main.xml sign_success.xml 两个activity文件 MainActivity signActivity 在AndroidManifest中注册两个Activity AndroidManifest.xml 结果 生命周期 打开app 点击登录 返回主页面 关闭 数据传递 要实现传递et1框内输入的数据只需更改两个Activity MainActivity signActivity 结果 "},{"title":"spring的事务管理","date":"2020-04-26T12:30:23.000Z","url":"/2020/04/26/spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/","tags":[["java","/tags/java/"]],"categories":[[" ",""]],"content":"spring的数据库编程spring提供了jdbc模板，对数据库操作 jdbc的配置 配置jdbc模板时要把dataSrouce注入到JdbcTemplate，在Dao时要把JdbcTemplate注入到bean中 JdbcTemplate通过update的增删改 JdbcTemplate通过 query 查询 RowMapper映射器把数据库的字段和类的属性对应起来 事务管理 事务就是一组操作，要么全做，要么全不做 编程式事务管理声明式事务管理"},{"title":"springAop","date":"2020-04-26T09:29:57.000Z","url":"/2020/04/26/springAop/","tags":[["java","/tags/java/"]],"categories":[[" ",""]],"content":"Aop概念面向切面编程， 指扩展功能不修改源代码，将功能代码从业务逻辑代码中分离出来 ；与oop面向对象编程相辅相成 通俗理解： 比如有几个业务，都要写日志，原来是分开都执行，现在把写日志功能抽出来，通过切面类去处理；其实aop也有一点解耦的思想 Aop术语切面：（Aspect）抽离出来的类 连接点：程序运行时的时间点 切入点：需要处理的连接点 通知：（advicce）切面类的方法 通知类型：嵌入目标对象方法时的插入类型 前置通知：在方法之前执行 后置通知：在方法之后执行 异常通知：方法出现异常执行 最终通知：在后置之后执行 环绕通知：在方法之前和之后执行 引入：允许添加实现类属性和方法 目标对象：被通知的对象 代理：通知加到目标后的创建的的对象 织入：将切面插入的代码的方法 编译期织入 类装载期织入 动态代理织入 动态代理 java有多种动态代理技术，最常用jdk和CGLib jdk的动态代理 只能对实现了接口的类生成代理，而不是针对类，该目标类型实现的接口都将被代理。原理是通过在运行期间创建一个接口的实现类来完成对目标对象的代理 CGLib的动态代理 针对类实现代理，对是否实现接口无要求。原理是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以被代理的类或方法最好不要声明为final类型 AspectJ开发 支持注解开发切面的注解集合被称为“@AspectJ”注解。在AspectJ5中，我们不仅可以使用基于注解的方式来开发切面，也可以使用基于代码的方式来开发切面，也可以混用它们"},{"title":"小结3","date":"2020-04-25T06:35:39.000Z","url":"/2020/04/25/%E5%B0%8F%E7%BB%933/","tags":[["小结","/tags/%E5%B0%8F%E7%BB%93/"]],"categories":[[" ",""]],"content":"翻了下上次的做小结的时间，是3月9号，是时间来做小结了；简单明了，最近一年的主要任务是复习备考，准备研究生考试，我在开始就做了一些计划；按二月份开始算，十二月考试，现在已经过去了三个月，整个复习时间是十一个月，已经过去了三分之一的时间了；翻开我的计划，对照我的进度，我已经比预期慢了；原因我想大概有两方面 一是很多事情影响，导致进度没有预想的那样；疫情的影响，差不多三月份开始开学上网课，我的情况是每个星期四节课，上午下午分别半天的课，这耽误了一些时间，有时候作业并不能马上完成，因为两门都是编程课，有时候一个bug去查，拖好几天才解决；还有就是我参加了一个嵌入式的学习小组，这也占用了一些时间；还有一些其他的时间占用，包括出门玩，这些都要分散精力；有些事情好像耽误了我考研的任务，但我觉得花时间是值得的，比如我给服务器重装了trojan面板，就是为了实现多用户限流的功能，由于我上一个在用版本的冲突，我又重装了系统，左右捣鼓了两天时间，才弄好，在这个过程中，我几乎把nginx服务器配置重新学了一遍，解决了一些linux系统的问题，这个虽然耽误了一些，但我觉得收获很大；但是其他一些时间的浪费就不值得了，比如懒床起不来，要懒在床上八点钟才起来；后面需要改变，尽量早点起，可能需要人监督；一直学习，不玩也不行，一直玩不学习更不行，每个星期拿一天时间玩，这个就自己掌握了 二就是自己的原因了，好像慢慢到现在，没有了刚开始的热情了，每天基本上是重复照搬的学习，就像是长跑，跑到没力气了，就只能拖着一样，说没跑吧，还是一直在学，就是很慢；就学习内容而言，我知道，速度慢下来是正常的，因为我学的这部分正好是最难的地方，积分学，而且需要大量的时间去练习；让我担心的是现在的学习状态，没有了激情（暂时也没什么好办法，可能那种学习打了鸡血的状态才是异常状态吧） 翻了翻过去一个月做的事情，现在来看，做这些也要一个月？不禁感觉有点好笑，不是说做的慢，而是这种心态的变化；第一次做是会慢一点，这正常；问题在于，我并没有感觉用尽全力去完成；我又没有尽全力，又想要一个好收成，这就很矛盾了；所以后面如果想松懈的时候，就要这么警戒自己；过去的就过去了，未来还在到来，总结问题，是为了更好进步 下面做下一段时间的计划 目前主要的重点还是英语和数学，现在的进度是高数微分学基本看完，课本上微分的练习做了一半，30讲的微分练习做了一遍，但效果不好，积分学看了一半了，主要问题是练习多，线性代数看了行列式和矩阵；英语每天背单词，才开始看长难句 计划 数学：线代部分跟上学校的节奏，积分学可以放慢一点；整体要控制在五月底的时候要把第一轮复习全部做完，目标是知识点理解和简单中等题，书是张宇系列；从今天算还有一个月，任务是积分学和线代大部分内容 英语：每天背单词25个（我一般要用两个小时），这个要一直持续到考试开始，后面熟练后可以考虑一点改动，语法长难句按章节来（2个小时），暂定六月处，开始真题了，归纳错题，每天两篇翻译全文 这个计划要尽量完成，一月之后再来检查情况"},{"title":"nginx配置","date":"2020-04-24T03:53:16.000Z","url":"/2020/04/24/nginx%E9%85%8D%E7%BD%AE/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":" Nginx 是轻量级高并发服务器，能实现反向代理，阿里主推;由于用到了nginx，做一下记录，实际上Nginx远不止这一点功能 什么是反向代理？要理解反向代理首先知道正向代理 正向代理pc1 pc2&lt;—-&gt;代理服务器&lt;—-&gt;服务器 pc3 处于局域网的pc自己不能上网（比如校园网），如果要上网，需要连接代理，通过代理去访问服务器 正向代理控制着pc可以访问的服务器内容 可以匿名多台pc的ip，此时pc对服务器来说是透明的 反向代理与正向代理相反，它代理的是不同服务器 反向代理控制pc可以访问的服务器内容 可以匿名多台服务器ip，此时n台服务器对pc是透明的 pc&lt;—-&gt;代理服务器&lt;—-&gt;n台服务器 反向代理优点是加强了安全性，还可以做负载均衡 Nginx配置 nginx.conf 1、全局块：nginx全局的指令 2、events块：配置nginx服务器或与用户的网络连接 3、http块：配置代理，缓存，日志定义 4、server块：配置虚拟主机参数 5、location块：配置请求的路由，以及页面处理情况 常用命令系统是centos7 "},{"title":"Activity","date":"2020-04-22T11:21:02.000Z","url":"/2020/04/22/Activity/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" Android四大组件：Activity、Service、Broadcast Receiver、Content Provider 什么是Activity Activity管理程序的交互界面；一个程序中通常由多个Activity构成，都会在Manifest.xml中指定一个主的Activity Activity生命周期Activity生命周期的有五个阶段 启动阶段 运行状态：处于屏幕最前端，可交互 暂停状态：可见，无法获取焦点，不可操作 停止状态：不可见，系统内存不足时会销毁Activity 销毁状态：清理出内存 其中启动和销毁是过渡阶段，不会长时间处于这两个状态 Activity生命周期的有7个方法 Void onCreate(Bundle savedInstanceState) Void onStart() Void onRestart() Void onResume() Void onPause() Void onStop() Void onDestroy() 状态切换对应的操作 启动： onCreate()—&gt;onStart()—&gt;onResume()，等待交互 切换后台： onPause()—&gt;onStop()，进入停止状态 返回前台： onRestart()—&gt;onStart()—&gt;onResume()，回到运行状态 Activity后台运行时，如果内存不足， 处于停止状态的Activity会被销毁 锁屏调用onPause() 解锁调用onResume() Android周期图示： 图片来源  Activity跳转Activity跳转需要用到intent（意图：是一种交互方式，还可以在不同组件传递数据） intent一般用于启动Activity，Service和广播 根据启动组件方式不同，又分为显示意图和隐式意图,显示意图指明启动的组件，隐式意图没有明确指定，而是通过action等属性分析，打开目标Activity intent组成 intent数据传递假设要实现从Activity1到Activity2，从Activity2回传数据 Activity1代码 第一行，创建一个跳转到Activity2的intent 第二行，startActivityForResult(int requestCode,intent data)跳转 Activity2代码 第一行，创建一个intent 第二行，调用putEXtra()添加回传数据 第三行，调用setResult(int resultCode,intent data)回传数据 Activity1想要接收Activity2回传的数据，要复写onActivityResult()方法接收 "},{"title":"一元积分学几何应用","date":"2020-04-22T01:15:07.000Z","url":"/2020/04/22/%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":" 设以下曲线都是连续的，用定积分求 平面图面积1.曲线围成的面积 2.射线与曲线围成的面积 旋转体体积1.曲线y=y(x)与x=a,x=b（a&lt;b）以及x轴围成的图形，绕x旋转一周得到的旋转体体积 2.曲线y=y1(x)≥0与y=y2(x)≥0及x=a,x=b（a&lt;b）围成的图形，绕x旋转一周得到的旋转体体积 3.曲线y=y(x)与x=a,x=b（a&lt;b）以及x轴围成的图形，绕y旋转一周得到的旋转体体积 4.曲线y=y1(x)与y=y2(x)及x=a,x=b（0≤a≤b）围成的图形，绕y旋转一周得到的旋转体体积 函数的平均值x∈[a,b],则y(x)在[a,b]上的平均值为 "},{"title":"仿照qq的Android界面","date":"2020-04-21T15:08:29.000Z","url":"/2020/04/21/%E4%BB%BF%E7%85%A7qq%E7%9A%84Android%E7%95%8C%E9%9D%A2/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":"layout MainActivity 效果图 "},{"title":"Android第一个HelloWorld","date":"2020-04-21T08:13:21.000Z","url":"/2020/04/21/Android%E7%AC%AC%E4%B8%80%E4%B8%AAHelloWorld/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":"修改布局文件app/res/layout/activity_main.xml 1.拖入TextView``Button,生成代码如下 2.修改app/java/MainACtivity 3.连接mumu模拟器 adb connect 127.0.0.1:7555 "},{"title":"定积分的计算","date":"2020-04-21T04:40:43.000Z","url":"/2020/04/21/%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E8%AE%A1%E7%AE%97/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"牛顿莱布利兹公式 下图来自 wiki 很好的解释了这个公式 方法定积分的凑微分法 定积分的换元积分法 定积分的分部积分法u ’ v ‘ 在[a,b]上连续 重要结论1.奇偶连续函数 2.周期连续函数 3.区间在现公式 4.华理士公式 "},{"title":"AndroidUI","date":"2020-04-20T11:39:43.000Z","url":"/2020/04/20/AndroidUI/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" android的界面是通过布局（Layout）文件设定的；文件位于res/layout中，这次重点就是来学习如何编写它 五种常用布局 以下图片均引自  LinearLayout（线性布局） RelativeLayout（相对布局） FrameLayout（帧布局） TableLayout（表格布局） AbsoluteLayout（绝对布局） 线性布局（LinearLayout）控件水平或者垂直排列，子组件以垂直或水平的方式来定位.(默认是垂直) android:orientation ：属性指定布局方向 android:orientation ： 定义布局内的方向水平或垂直（horizontal/vertical ） android:layout_weight ：子元素对未占用空间【水平或垂直】分配权重值，其值越小，权重越大 android:layout_width ：宽（1.fill_parent: 父元素决定，2.wrap_content: 本身的内容决定） android:layout_height ： 高（3.高直接指定一个 px 值）； android:gravity：内容的排列形式（常用 top, bottom, left, right,centerLeft|center_) 表格布局（TableLayout）类似Html里的Table.使用TableRow来布局，其中TableRow代表一行，TableRow的每一个视图组件代表一个单元格 collapseColumns：设置需要被隐藏的列的列序号，多个列序号之间用逗号隔开； shrinkColumns：设置允许被收缩的列序号，多个列序号之间用逗号隔开； stretchColumns：设置允许被拉伸的列序号，多个列序号之间用逗号隔开。 相对布局（RelativeLayout）依赖其他组件或是顶层父组件确定下一个组件的位置，所以要定位一个组件，就要定义它依赖的组件位置 android:layout_below：在某元素的下方 android:layout_above：在某元素的上方 android:layout_toLeftOf：在某元素的左边 android:layout_toRightOf：在某元素的右边 android:layout_alignXxx：控制与某元素的边界对其方式 帧布局（FrameLayout）所有添加到这个布局中的视图以层叠的方式显示，并且后遮挡先声明的控件 帧布局的大小由控件最大的确定 android:foreground :前景图 android:foregroundGravity :前景图位置 绝对布局（AbsoluteLayout）采用坐标轴的方式定位组件，左上角是（0，0）点，往右x轴递增，往下Y轴递增；每个子组件都需要通过两个XML属性来确定坐标：layout_x:指定该子组件的X坐标；layout_y:指定该子组件的Y坐标，由于使用很繁琐，基本上不用 常用组件TextView文本框 android:id 设置一个组件id android:layout_width 组件的宽度 android:layout_height 组件的高度 android:gravity 文本位置 android:text 文本内容 android:textColor 字体颜色 android:textStyle 字体风格 android:textSize 字体大小 android:background 背景颜色 EditText输入框 android:hint 提示的文本内容 android:textColorHint 提示文本的颜色 android:selectAllOnFocus 设为true的EditText获得焦点后 选中的是所有文本 android:inputType 限制输入 android:minLines 设置最小行的行数 android:maxLines 设置EditText最大的行数 android:textScaleX 设置字与字的水平间隔 android:textScaleY 设置字与字的垂直间隔 Button(按钮)与ImageButton(图像按钮) state_enabled:控件是否可用 state_checkable:控件可否被勾选,eg:checkbox state_checked:控件是否被勾选 ImageView(图像视图)"},{"title":"Android目录","date":"2020-04-20T10:57:40.000Z","url":"/2020/04/20/Android%E7%9B%AE%E5%BD%95/","tags":[["android","/tags/android/"]],"categories":[[" ",""]],"content":" 做一些Android学习的记录 新建的Android项目结构（环境Android studio） 整理如下 manifests：程序配置信息 java：编写的Java代码 res：资源目录 drawable 图片 layout 布局文件 mipmap 图标 values 字符串 gradle：自动化构建工具 AndroidManifest.xml 代码 属性 android:allowBackup=&quot;true&quot; 备份数据开 android:icon=&quot;@mipmap/ic_launcher&quot; 图标 android:label=&quot;@string/app_name&quot; 标题栏名称 android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; 图标适配 android:supportsRtl=&quot;true&quot; 支持rtl布局 android:theme=&quot;@style/AppTheme&quot; 全局主题样式 &lt;activity android:name=&quot;.MainActivity&quot;&gt; 注册一个activity &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; 当前activity最先启动 &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; 显示在应用列表中 "},{"title":"android网络与通信编程","date":"2020-04-20T05:56:20.000Z","url":"/2020/04/20/android%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A8%8B/","tags":[["android","/tags/android/"],["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[[" ",""]],"content":"HTTP协议 超文本传输协议（HTTP）是一种应用协议用于分布式，协作，超媒体信息系统。[1] HTTP是万维网数据通信的基础，超文本文档包括指向用户可以轻松访问的其他资源的超链接，例如，通过单击鼠标或在Web浏览器中点击屏幕。 ——wiki HTTP 完整流程: 浏览器向服务器发送一个 HTTP 格式的 request 服务器处理 request，向浏览器返回一个 Http 格式的 response 重复1、2步，请求其他资源 以谷歌学术为例，下面代码做了简化处理 Request Header 1：浏览器发出请求 请求头包括 方法：GET还是POST，GET仅请求资源，POST会附带用户数据 路径：/ HTTP报文头报文头：accept:包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息 其他相关Header Cache-Control ：缓存控制 如以下设置，相当于让服务端将对应请求返回的响应内容不要在客户端缓存： 如果是POST，那么请求还包括一个Body，包含用户数据 2：服务器发出响应 Response Header 响应报文比请求报文相多了一个“响应状态码”，它表示浏览器请求的处理结果 响应代码有： 200表示成功 3xx表示重定向， 4xx表示客户端发送的请求有错误 5xx表示服务器端处理时发生了错误 响应类型：Content-Type: text/html表示响应类型是HTML文本 其他的Header 步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2 详细属性见developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers HTTP GET格式： HTTP POST格式： HTTP响应的格式： 注意\\r\\n\\r\\n分隔header 和 body url 统一资源定位符 说完了方法，再来说一下url ： http通过统一资源定位器（URL）标识HTTP资源 来自 wiki 比如 名称 含义 http:// 是协议 example.com 域名 5000 端口号 path/me.html 资源的路径 ?key1=value1&amp;key2=value2 额外参数(用 &amp; 符号分隔的键/值对) 整个访问过程是，url通过http协议发出去，DNS服务器把域名解析为对应ip地址，服务器在5000端口上监听用户的请求，当监听到请求之后，返回数据给客户端 HTTP特点 支持bs和cs 简单：只需传送方法和路径 灵活：允许传输任意类型数据对象 无连接： 限制每次连接只处理一个请求;服务器处理完请求，并收到应答后，即断开连接 无状态： 协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态 Android网络接口 Android平台有三种网络接口可以使用，他们分别是：java.net.*(标准Java接口)，org.apache(Apache接口)，和android.net.（android网络接口） ; android.net. 实际上是通过对 Apache 的 HttpClient 的封装来实现的一个 HTTP 编程接口 HttpURLConnection 使用 HttpUrlConnection 来进行网络请求大致上可以分为4个步骤： 获取到 HttpUrlConnection 对象 进行全局的网络设置并建立 Http 连接 进行数据处理 关闭连接 HttpClient 创建HttpClient对象。 创建对应的发送请求的对象，如果需要发送GET请求，则创建HttpGet对象，如果需要发送POST请求，则创建HttpPost对象。 对于发送请求的参数，GET和POST使用的方式不同，GET方式可以使用拼接字符串的方式，把参数拼接在URL结尾；POST方式需要使用setEntity(HttpEntity entity)方法来设置请求参数。 调用HttpClient对象的execute（HttpUriRequest request）发送请求，执行该方法返回一个HttpResponse对象。 调用HttpResponse的对应方法获取服务器的响应头、响应内容等。 "},{"title":"常用端口号","date":"2020-04-19T09:38:13.000Z","url":"/2020/04/19/%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":" 端口 含义 21 FTP 22 SSH 23 Telnet 25 SMTP 53 DNS（UDP） 69 TFTP（cisco，类似FTP） 80 HTTP 110 POP3 443 HTTPS 1080 socks代理服务 5900 vnc 8000 腾讯 "},{"title":"积分计算不定积分","date":"2020-04-17T06:59:08.000Z","url":"/2020/04/17/%E7%A7%AF%E5%88%86%E8%AE%A1%E7%AE%97/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"五个基本方法公式法 凑微分 思想 例题 换元法 把复杂的东西化简 三角代换 恒等变形后三角代换 根式代换 遇见无法代换的式子就令为t 倒代换 把分母次数高的换下来，令t=1/x 分部积分法 此法适合右边容易左边难的情形 一般规律，u求导，v积分 反对幂指三，先念的人求导 推导的分部积分法 用数学归纳法，可以得出n阶的分部积分法 错位相乘，正负相间，最后一项放到积分中 例子 考点 1 . ∫uvdx ，uv具有连续(n+1)阶导数，积分(n+1)次 公式带入 2 . ∫uvdx ，指数函数和对数函数，积分两次，见方程 因为不管u，v怎么导，积分，可以做无穷次，故名积分再现 3 . ∫uvdx ，对数和幂函数，积分一次 有理函数的积分 定义 先将Q(x)因式分解，拆成最简有理分式之和；化繁为简，逐个击破 "},{"title":"SpringBean","date":"2020-04-14T04:08:55.000Z","url":"/2020/04/14/SpringBean/","tags":[["java","/tags/java/"]],"categories":[[" ",""]],"content":"Bean的配置 详见bean是什么 属性 描述 id id为bean的唯一标识名，，在整个XML中唯一 name 为bean id创建一个或多个别名（区别于id）。如果没有定义bean的id，那么第一个别名就会被作为id；如果也没有定义name，那么自动生成一个id和一个别名（这时的别名为类的全类名且类名首子母小写） class 定义类的全限定名（包名＋类名）；只有子类Bean不用定义该属性 parent 子类Bean定义它所引用它的父类Bean,这时class属性失效。子类Bean会继承父类Bean的所有属性，子类Bean也可以覆盖父类Bean的属性;注意：子类Bean和父类Bean是同一个Java类 abstract 默认为”false”，用来定义Bean是否为抽象Bean;它表示这个Bean将不会被实例化，一般用于父类Bean，因为父类Bean主要是供子类Bean继承使用 scope 默认为singleton（单例）;如果设prototype（原型）状态，BeanFactory将为每次Bean请求创建一个新的Bean实例 lazy-init 定义Bean是否实现懒初始化;默认为“default” ，如果为“true”，它将在BeanFactory启动时初始化所有的SingletonBean;反之，如果为“false”,它只在Bean请求时才开始创建SingletonBean autowire 定义Bean的自动装载方式1.“no”:不使用自动装配功能2.“byName”:通过Bean的属性名实现自动装配3.“byType”:通过Bean的类型实现自动装配4.“constructor”:类似于byType，但它是用于构造函数的参数的自动组装5.“default”：默认值，自动装配 depends-on Bean在初始化时依赖的对象，这个对象在这个Bean初始化之前创建 destroy-method 定义Bean的销毁方法，它在BeanFactory关闭时调用；是一个无参数的方法，只能应用于singletonBean factory-method 创建Bean对象的工厂方法 factory-bean 创建Bean对象的工厂类；如果使用了“factory-bean”则“class”属性失效 Spring 配置元数据有下面三个重要的方法把配置元数据提供给 Spring 容器： 基于 XML 的配置文件 基于注解的配置 基于 Java 的配置 Bean的作用域 作用域 描述 singleton 该作用域将 bean 的定义的限制在每一个 Spring IoC 容器中的一个单一实例(默认)。 prototype 该作用域将单一 bean 的定义限制在任意数量的对象实例。 request 该作用域将 bean 的定义限制为 HTTP 请求。只在 web-aware Spring ApplicationContext 的上下文中有效 session 该作用域将 bean 的定义限制为 HTTP 会话。 只在web-aware Spring ApplicationContext的上下文中有效 global-session 该作用域将 bean 的定义限制为全局 HTTP 会话。只在 web-aware Spring ApplicationContext 的上下文中有效 singleton 作用域：如果作用域设置为 singleton，那么 Spring IoC 容器刚好创建一个由该 bean 定义的对象的实例。该单一实例将存储在这种单例 bean 的高速缓存中，以及针对该 bean 的所有后续的请求和引用都返回缓存对象。 默认作用域是始终是 singleton，但是当仅仅需要 bean 的一个实例时，你可以在 bean 的配置文件中设置作用域的属性为 singleton，如下所示： Bean的生命周期理解 Spring bean 的生命周期很容易。当一个 bean 被实例化时，它可能需要执行一些初始化使它转换成可用状态。同样，当 bean 不再需要，并且从容器中移除时，可能需要做一些清除工作。 尽管还有一些在 Bean 实例化和销毁之间发生的活动，但是本章将只讨论两个重要的生命周期回调方法，它们在 bean 的初始化和销毁的时候是必需的。 为了定义安装和拆卸一个 bean，我们只要声明带有 init-method 和/或 destroy-method 参数的 。init-method 属性指定一个方法，在实例化 bean 时，立即调用该方法。同样，destroy-method 指定一个方法，只有从容器中移除 bean 之后，才能调用该方法。 Bean的生命周期可以表达为：Bean的定义——Bean的初始化——Bean的使用——Bean的销毁 Bean的装配方式 基于XML的装配 基于注解的装配 自动装配 基于XML的装配方式一：设置注入 ：**在配置文件中，使用元素来为每个属性注入值** 方式二：构造注入：**在配置文件中，使用元素来为参数注入值** 基于注解的装配基于XML的装配可能会导致XML配置文件过于臃肿，Spring提供Annotation（注解）来解决问题 自动装配 自动装配，就是将一个Bean自动的注入到到其他Bean的Property中。 Spring的元素中包含一个autowire属性，我们可以通过设置autowire的属性值来自动装配Bean。autowire属性有5个值，其值及说明下表所示： 参考： Spring Bean 定义 spring bean元素的内置属性和子元素 Spring中Bean的装配方式 "},{"title":"依赖注入类型","date":"2020-04-14T01:08:13.000Z","url":"/2020/04/14/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B/","tags":[["java","/tags/java/"]],"categories":[[" ",""]],"content":"spring通过java的反射机制，动态的把依赖的对象注入bean中 ；DI有两种方法：基于构造函数的DI和基于 setter 方法 的DI 反射是程序可以访问、检测和修改它本身状态或行为的一种能力 ；通俗的说就是，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载 示例步骤1.导入依赖包 2.创建接口类TestDI，TestDIServer 3.创建实现类TestDIImpl，TestDIServerImpl1，TestDIServerImpl2 4.测试类test 5.配置bean文件 applicationContext.xml 代码TestDI接口 TestDIImpl实现类 TestDIServer接口 TestDIServerImpl1实现类 TestDIServerImpl2实现类 test applicationContext.xml 结果 "},{"title":"行列式3","date":"2020-04-13T09:22:58.000Z","url":"/2020/04/13/%E8%A1%8C%E5%88%97%E5%BC%8F3/","tags":[["考研","/tags/%E8%80%83%E7%A0%94/"],["线性代数","/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"]],"categories":[[" ",""]],"content":"具体型化基本形方法直接展开 1.元素中有足够多的0 2.阶数不高 爪形 斜爪消平爪 异爪形 1.n=4展开 2.高阶递推 行列和相等 消零化基本形 拉普拉斯展开 范德蒙行列式 递推法关键是找到Dn和Dn-1的关系 行列式表示的函数和方程抽象型用性质 用公式 余子式与代数余子式的计算"},{"title":"SpringIoc容器","date":"2020-04-11T09:02:00.000Z","url":"/2020/04/11/SpringIoc%E5%AE%B9%E5%99%A8/","tags":[["java","/tags/java/"]],"categories":[[" ",""]],"content":" 参考：   控制反转Ioc**(Inversion of Control)，即“控制反转”，不是技术，而是一种设计思想，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活 传统做法 控制反转 区别 直接在对象内部通过new创建对象 Ioc容器来控制对象的创建 控制者 程序主动去创建依赖对象 IoC 容器控制了对象 主动关系 在对象中主动控制去直接获取依赖对象 容器进行查找及注入依赖对象，对象只是被动的接受依赖对象 控制了什么：控制了外部资源获取（不只是对象，包括比如文件等） 反转了什么：依赖对象的获取被反转了 依赖注入 DI(Dependency Injection)，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现 谁依赖于谁：应用程序依赖于IoC容器 为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源 谁注入谁：IoC容器注入应用程序某个对象，应用程序依赖的对象 注入了什么：注入某个对象所需要的外部资源（包括对象、资源、常量数据） Bean 由IoC容器管理的那些组成你应用程序的对象我们就叫它Bean， Bean就是由Spring容器初始化、装配及管理的对象 Spring 提供了以下两种不同类型的容器 名称 描述 BeanFactory org.springframework.beans包中的BeanFactory接口,提供了IoC容器最基本功能 ApplicationContext.xml org.springframework.context包下的ApplicationContext接口扩展了BeanFactory，还提供了与Spring AOP集成、国际化处理、事件传播及提供不同层次的context实现 (如针对web应用的WebApplicationContext) IoC容器工作 方式一、准备配置文件：配置Bean元数据 二、由IoC容器进行解析元数据： IoC容器的Bean Reader读取并解析配置文件，根据定义生成BeanDefinition配置元数据对象，IoC容器根据BeanDefinition进行实例化、配置及组装Bean 三、实例化IoC容器：由客户端实例化容器，获取需要的Bean "},{"title":"spring入门","date":"2020-04-09T02:19:49.000Z","url":"/2020/04/09/spring%E5%85%A5%E9%97%A8/","tags":[["java","/tags/java/"]],"categories":[[" ",""]],"content":"spring体系结构 此部分摘录自：  以下内容作为了解，学习只需掌握部分 Spring 框架提供约 20 个模块，可以根据应用程序的要求来使用。 核心容器核心容器由spring-core，spring-beans，spring-context，spring-context-support和spring-expression（SpEL，Spring表达式语言，Spring Expression Language）等模块组成，它们的细节如下： spring-core模块提供了框架的基本组成部分，包括 IoC 和依赖注入功能。 spring-beans 模块提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。 context模块建立在由core和 beans 模块的基础上建立起来的，它以一种类似于JNDI注册的方式访问对象。Context模块继承自Bean模块，并且添加了国际化（比如，使用资源束）、事件传播、资源加载和透明地创建上下文（比如，通过Servelet容器）等功能。Context模块也支持Java EE的功能，比如EJB、JMX和远程调用等。ApplicationContext接口是Context模块的焦点。spring-context-support提供了对第三方库集成到Spring上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。 spring-expression模块提供了强大的表达式语言，用于在运行时查询和操作对象图。它是JSP2.1规范中定义的统一表达式语言的扩展，支持set和get属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。 它们的完整依赖关系如下图所示： 数据访问/集成数据访问/集成层包括 JDBC，ORM，OXM，JMS 和事务处理模块，它们的细节如下： （注：JDBC=Java Data Base Connectivity，ORM=Object Relational Mapping，OXM=Object XML Mapping，JMS=Java Message Service） JDBC 模块提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码的解析。 ORM 模块提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理。 OXM 模块提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。 JMS 模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了spring-messaging模块。。 事务模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细） WebWeb 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下： Web 模块提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。 Web-MVC 模块为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。 Web-Socket 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。 Web-Portlet 模块提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。 其他还有其他一些重要的模块，像 AOP，Aspects，Instrumentation，Web 和测试模块，它们的细节如下： AOP 模块提供了面向方面的编程实现，允许你定义方法拦截器和切入点对代码进行干净地解耦，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。 Aspects 模块提供了与 AspectJ 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。 Instrumentation 模块在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。 Messaging 模块为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。 测试模块支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。 spring入门程序步骤1.创建项目，导入依赖包 2.创建接口 3.创建接口实现类 4.创建配置文件(一般命名为applicationContext.xml) 目录 代码 代码来自参考书 接口TestDao 接口实现类TestDaoImpl 配置applicationContext.xml 测试类Test 分析 参考：  第一步是我们使用框架 API ClassPathXmlApplicationContext() 来创建应用程序的上下文;这个 API 加载 beans 的配置文件并最终基于所提供的 API，它处理创建并初始化所有的对象，即在配置文件中提到的 beans 第二步是使用已创建的上下文的 getBean() 方法来获得所需的 bean。这个方法使用 bean 的 ID 返回一个最终可以转换为实际对象的通用对象;一旦有了对象，你就可以使用这个对象调用任何类的方法 当 Spring 应用程序被加载到内存中时，框架利用了上面的配置文件来创建所有已经定义的 beans，并且按照标签的定义为它们分配一个唯一的 ID "},{"title":"ssm学习","date":"2020-04-09T01:09:22.000Z","url":"/2020/04/09/ssm%E5%AD%A6%E4%B9%A0/","tags":[["java","/tags/java/"]],"categories":[[" ",""]],"content":"前言 休息了两天，今天又正式回到复习阶段，前些时候专门在复习高数，学校的网课都没怎么听，现在发现已经落下很多了；准备自学，写一系列笔记；目标是速成，应付考试，所以不会很详细； 参考书：JavaEE框架整合开发入门到实战 学校网课 框架 思路迅速理解主干，再去补充分支点 为啥看这段？属于那部分 这段写了啥？怎么理解 看不懂咋办？知识间的逻辑 ssm简介 SSM即SpringMVC、Spring、Mybatis三个框架 ，是一个适用于搭建企业级应用系统 的框架 框架？ 框架则是为解决一个(一类)问题而开发的产品，框架用户一般只需要使用框架提供的类 或函数，即可实现全部功能；通俗理解，就是解决一类问题的套路，用户只用完善后面 的逻辑就能方便的搭建系统 以下内容转载：详见 MVC与三层架构 浅谈 MVC、MVP 和 MVVM 架构模式 MVC和web三层模型MVC是一种设计模式， 三层模型是一种软件架构 ，目的都是为了 解耦，提高代码复用 MVC设计模式模型Model 管理应用的行为和数据，响应数据请求（经常来自视图）和更新状态的指令（经常来自控制器） 视图View 管理作为位图展示到屏幕上的图形和文字输出 控制器Controller 翻译用户的输入并依照用户的输入操作模型和视图 三层模型视图层View 用于接收用户提交请求的代码在这里编写 服务层Service 系统的业务逻辑主要在这里编写 持久层Dao 直接操作数据库的代码在这里编写 MVC与三层架构的关系MVC与三层架构很相似，但它们并不一样。如果以三层架构为背景，那么MVC的三个部分分别对应的是什么？ 三层架构中的View层简单的说就是跟用户发生直接关系的层，MVC中的V和C就是这样的存在，所以MVC中的V和C均属于三层架构的View层。同时，我们知道MVC中的M（Model）包括了数据承载Bean和业务处理Bean，其中业务处理Bean分为Service或Dao对象，分别对应业务逻辑处理和数据库操作，相应的，它们对应的是三层架构中的Service层和Dao层。故，它们的关系如下图所示： MVC与三层架构的关系 SSM与三层架构的关系SSM即SpringMVC、Spring、Mybatis三个框架。它们在三层架构中所处的位置是不同的，即它们在三层架构中的功能各不相同，各司其职。 SpringMVC：作为View层的实现者，完成用户的请求接收功能。SpringMVC的Controller作为整个应用的控制器，完成用户请求的转发及对用户的响应。 MyBatis：作为 Dao层的实现者，完成对数据库的增、删、改、查功能。 Spring：以整个应用大管家的身份出现。整个应用中所有的Bean的生命周期行为，均由Spring来管理。即整个应用中所有对象的创建、初始化、销毁，及对象间关联关系的维护，均由Spring进行管理。 "},{"title":"变限积分与反常积","date":"2020-04-05T02:52:06.000Z","url":"/2020/04/05/%E5%8F%98%E9%99%90%E7%A7%AF%E5%88%86%E4%B8%8E%E5%8F%8D%E5%B8%B8%E7%A7%AF/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":" 这一章知识点符号太多了，一个个打出来截图很耽误时间，没办法，偷个懒拍照记下来，最重要的还是理解，多做题多思考 变限积分概念 如果上限x在区间[a,b]上任意变动，则对于每一个取定的x值，定积分有一个对应值，所以它在[a,b]上定义了一个函数，这就是积分变限函数 性质 若函数f(x)在区间[a,b]上可积，则积分变上限函数在[a,b]上连续 若函数f(x)在区间[a，b]上连续，则积分变上限函数在[a,b]上可导 变限积分求导公式 反常积分理解定积分有两个限制，一是有限区间，二是被积函数有界，将这两项打破，得到能求出的积分，称为反常积分；区间无穷的叫无穷积分，被积函数无解的叫瑕积分 几何意义函数与X轴所围面积存在有限制时，即便函数在一点的值无穷，但面积可求 敛散性 反常积分讨论敛散性，自然要分成两种，一种是无穷区间，一种是无界函数 无穷区间上反常积分的敛散性设f(x)定义为[a,+∞)，函数在[a,b]上可积，则 称为无穷积分 若极限不存在，则无穷积分发散 具体： 无界函数上反常积分的敛散性 "},{"title":"祭奠","date":"2020-04-04T02:17:32.000Z","url":"/2020/04/04/%E7%A5%AD%E5%A5%A0/","tags":[["其他","/tags/%E5%85%B6%E4%BB%96/"]],"categories":[[" ",""]],"content":" 为表达全国各族人民对抗击新冠肺炎疫情斗争牺牲烈士和逝世同胞的深切哀悼，国务院今天发布公告，决定2020年4月4日举行全国性哀悼活动。在此期间，全国和驻外使领馆下半旗志哀，全国停止公共娱乐活动。4月4日10时起，全国人民默哀3分钟，汽车、火车、舰船鸣笛，防空警报鸣响。 逝者安息，生者奋进 看到很多网站都改成了黑白色，参加祭奠，于是加入 添加新css样式 "},{"title":"定积分","date":"2020-04-02T08:52:04.000Z","url":"/2020/04/02/%E5%AE%9A%E7%A7%AF%E5%88%86/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"知识点 不定积分与定积分的区别所有的原函数称为不定积分 不定积分运算是求导的逆运算 定积分是f与x轴围成面积，由N-L和不定积分联系 不定积分结果是一个函数，而定积分结果是个数"},{"title":"不定积分","date":"2020-03-31T08:03:57.000Z","url":"/2020/03/31/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":" 补充：达布定理又称导数介质定理（用于解释上面关于间断点内容） 证明：  达布定理说明了这样一件事：如果一个函数可导，那么它的导函数只要能取到a,b两个值，那么就必然可以取到（a,b）内的所有值 如果一个函数可导，那么，他是导不出跳跃，可去，无穷间断点的，但是可能导数振荡间断点"},{"title":"[数学错题]序","date":"2020-03-29T13:12:31.000Z","url":"/2020/03/29/%E6%95%B0%E5%AD%A6%E9%94%99%E9%A2%98-%E5%BA%8F/","tags":[["数学错题","/tags/%E6%95%B0%E5%AD%A6%E9%94%99%E9%A2%98/"]],"categories":[[" ",""]],"content":" 这个标签一系列的文章，都记录了一些错题，整理一些思考过程，我认为是有意义，有价值的；看似好像有点浪费时间，但是，每次找到问题所在，是很开心的；就像编程一样，每次解决bug，总是很欣喜的，都有所收获；或多或少是哪里认识不足，暴露出来的问题，都值得深思；最后，你会发觉不管是数学也好，还是计算机，都是极其精确细致的学科，是什么样子就是什么样子，不容半点马虎；思路和操作正确，他就能得到正确结论，反之亦然；希望通过不断的纠错，加深对知识使的认识；很多编程大佬，都能解决很多问题，那是不是解决了足够多的问题，就能做大佬呢？我想，这是个充分不必要条件 "},{"title":"定义域错误","date":"2020-03-29T09:41:15.000Z","url":"/2020/03/29/%E5%AE%9A%E4%B9%89%E5%9F%9F%E9%94%99%E8%AF%AF/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"],["数学错题","/tags/%E6%95%B0%E5%AD%A6%E9%94%99%E9%A2%98/"]],"categories":[[" ",""]],"content":"今天遇到一道证明不等式的题，贴上我的错误步骤 先说我的思路,看到题目，我觉得题目给的形式很好，两边正好可以看成一个函数形式，做辅助函数，这样，只要求出辅助函数的增减性，就能比大小 所以我写出了我的过程，很顺利，一直到求导后大于零，然后就写不下去了，因为我发现我得出的结论和结论不符 然后，我翻阅了答案 答案是直接取对数变形的，然后是规范的操作 但是还是没有解决问题，我始终觉得思路没问题，过程也对，但是得到错误的结论，则必然其中哪一环有问题 经过和同学讨论，我先是怀疑不等式两边的函数不能看成是一个函数 我对它们的增减性做了验证 结果是这两个函数的增减性，都是一样的，问题应该不在这 我在进一步画出图像的时候就明白了原因 题目中的x定义域是(0,1)，而实际上1/x已经跑出这个范围了，函数在（0，1）确实是增的没错，但是这个增加已经管不到1/x了，所以，现在再来比较x，和1/x的函数值，就不能通过(0,1)的单调性来比，这样比就没有意义；不能用前朝的剑斩今朝的官 最后结论是：这个思路可以解决部分类型题，这题它失效了；用这种方法要确保变量在同一个确定单调性的区间内才可以 数学果然是一门充满陷阱的学科"},{"title":"微分不等式","date":"2020-03-28T01:42:58.000Z","url":"/2020/03/28/%E5%BE%AE%E5%88%86%E4%B8%8D%E7%AD%89%E5%BC%8F/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"微分不等式函数性态证明不等式单调性，凹凸性，最值 函数导数单调性 函数二阶导数凹凸性 函数唯一的极值，是最值点 凹函数，f(a)=f(b)=0,则f(x)&lt;0 常数变化量证明不等式将其中一个或几个常数变量化，再利用导数工具证明 中值定理证明不等式拉格朗日中值定理或泰勒公式"},{"title":"行列式2","date":"2020-03-27T06:54:21.000Z","url":"/2020/03/27/%E8%A1%8C%E5%88%97%E5%BC%8F2/","tags":[["考研","/tags/%E8%80%83%E7%A0%94/"],["线性代数","/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"]],"categories":[[" ",""]],"content":"重要的行列式主对角线行列式1.主对角线行列式 2.副对角线行列式 *副对角线行列式后面逆序为（n n-1 n-2 ··· 1）逆序数为n-1+n-2+ ··· +1=(n-1+1)(n-1)/2** 3.拉普拉斯展开式设A为m阶矩阵，B为n阶矩阵，则 *下面要变成上面的，要换mn次行，所以多了-1^(nm)** 4.范德蒙德行列式 特点： 第一行全是1（0次方） 第二行 x1 x2 ··· xn（的1次方） ··· 第n行 x1 x2 ··· xn（的n-1次方） 结论： 1.看第二行 2.高的减低的"},{"title":"中间人攻击","date":"2020-03-26T14:08:30.000Z","url":"/2020/03/26/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/","tags":[["网络安全","/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"今天查看博客一直显示隐私错误，我怀疑是不是证书到期了，或者是配置的问题，检查了一下，结果发现被攻击了 以下转自蓝点网  从目前网上查询的信息可以看到此次攻击涉及最广的是 GitHub.io，其次用户访问京东等国内知名网站亦会报错。 查看证书信息可以发现这些网站的证书被攻击者使用的自签名证书代替，导致浏览器无法信任从而阻止用户访问。 自签名证书显示证书的制作者昵称为心即山灵 (QQ346608453)，这位心即山灵看起来就是此次攻击的始作俑者。 所幸目前全网绝大多数网站都已经开启加密技术对抗劫持，因此用户访问会被阻止而不会被引导到钓鱼网站上去。 如果网站没有采用加密安全链接的话可能会跳转到攻击者制作的钓鱼网站，若输入账号密码则可能会被直接盗取。 那么什么是中间人攻击 维基百科 中间人攻击（英语：Man-**in-the-middle attack，缩写：MITM）在密码学和计算机安全领域中是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。 一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。 相当于本来直接和服务器通讯，加了个中间人，他夹在中间， 客户端→伪装劫持者→服务器 ，处在中间见风使舵，劫持信息，修改成想要的信息完成攻击 这次应该针对的是国内访问固定ip段做的重定向，修改成全局代理，走国外ip可以解除影响 "},{"title":"零点问题","date":"2020-03-26T00:03:06.000Z","url":"/2020/03/26/%E9%9B%B6%E7%82%B9%E9%97%AE%E9%A2%98/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"零点问题零点定理（主要证明存在性）若f(x)在闭区间[a,b]连续，f(a)f(b)&lt;0,则f(x)=0,至少有一根 推广的零点定理 单调性（主要证明唯一性）若f(x)在开区间(a,b)内单调，则f(x)=0,至多有一根 a,b可以是有限数，也可以是无穷大 罗尔原话(罗尔定理的推论)n阶导数方程k个根，则f(x)=0至多k+n个根 实系数奇次方程至少一个实根"},{"title":"行列式1","date":"2020-03-25T12:00:35.000Z","url":"/2020/03/25/%E8%A1%8C%E5%88%97%E5%BC%8F1/","tags":[["考研","/tags/%E8%80%83%E7%A0%94/"],["线性代数","/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"]],"categories":[[" ",""]],"content":"本质定义 第一种定义 n阶行列式是由n个n维向量的组成的，运算结果为以这n个向量为临边的n维图形的体积 结果为0，以2阶行列式为例，两个向量平行，线性相关 行列式的性质 性质一 行列互换，其值不变 行的性质，列的性质都满足 性质二 行列式中某行（列）为0，行列式为0 一个向量缩到零点，行列式为0 性质三 倍乘性质 某行（列）元素的公因子可以提出 性质四 单行可拆性 行列式某行（列）均是两个元素相加，可以拆成两个行列式 性质五 互换性 行列式两行（列）互换，行列式反号 性质六 行列式两行（列）对应成比例，行列式为0 两个向量夹角为0，行列式为0 性质七 倍加性质 行列式某行（列）的k倍数加到另一行（列），行列式值不变 可以从性质四 单行可加来证明 代数定义 第二种定义 排列由n个数排成的有序数组，称为一个n级排列 逆序一个大数排在一个小数前面，称为一个逆序 逆序数逆序的总数 奇排列和偶排列排列的逆序数是奇数，称为奇排列；排列的逆序数是偶数，称为偶排列 行列式的逆序数定义每一项取自不同行不同列，n个乘积组成的，符号由逆序数决定 例子确定符号：a12 a31 a54 a43 a25 这由五项，肯定来自五阶行列式 1.排序 a12 a25 a31 a43 a54 2.确定符号 -1^(25134) 逆序数为4所以为正 行列式展开定理 第三种定义：当n大于3，用逆序数表示的行列式就十分复杂，就有了行列式展开定理 余子式 在 n 阶行列式中，去掉aij 的第 i 行和第 j 列，剩下的按原来顺序与位置组成的 n – 1 阶行列式称为元素 aij 的余子式（记作 Mij） 代数余子式余子式Mij乘**-1^(i+j)后称为aij 的代数余子式，记为Aij** 展开公式 行列式等于它任意一行(列)的各元素与其对应的代数式余子式乘积之和 "},{"title":"google","date":"2020-03-21T08:09:11.000Z","url":"/2020/03/21/google/","tags":[["收藏","/tags/%E6%94%B6%E8%97%8F/"]],"categories":[[" ",""]],"content":""},{"title":"git上传异常","date":"2020-03-15T09:12:21.000Z","url":"/2020/03/15/git%E4%B8%8A%E4%BC%A0%E5%BC%82%E5%B8%B8/","tags":[["git","/tags/git/"]],"categories":[[" ",""]],"content":"上传时卡在这一步： 通过文档查到这条命令 文档：  gc 是garbage collection的缩写 ，我的仓库中文件比较多了，以前一直没有清理过，这个错误可能是因为产生垃圾太多 简单指令 仔细检查清理 检查仓库，如果情况良好，不执行gc 不要整理任何零散的文件 "},{"title":"泰勒展开的错误","date":"2020-03-15T08:20:46.000Z","url":"/2020/03/15/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E7%9A%84%E9%94%99%E8%AF%AF/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"],["数学错题","/tags/%E6%95%B0%E5%AD%A6%E9%94%99%E9%A2%98/"]],"categories":[[" ",""]],"content":"常用的泰勒展开式都是x趋于0的公式，当x趋近于x0时，误差o(x)是高阶无穷小，泰勒展开很少的项就能很精确的计算出f(x)的值;当x远离x0时，误差会越来越大，如果x趋于无穷，则此时展开很少的项，皮亚诺余项会是高阶无穷大 错误步骤记录 从第二步就错了， 当x→0，ln(x+1)～x ；而当 x→∞ 时是不成立的 正确步骤 补充一个数列求极限夹逼法的一般性结论 高数还需要大量的联系，知识点也要常复习"},{"title":"中值定理的证明","date":"2020-03-13T02:42:12.000Z","url":"/2020/03/13/%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"概念零点:f(x)=0的点(零点不是一个点) 极值点:邻域内的最值点(不一定要可导) 最值点:区间内的最值点 驻点:导数等于0的点 拐点:一阶导数的极值点(凹弧凸弧连接点) 证明费马定理极值点可导，导数为0 最后一步戴帽法：函数≥0，函数极限≥0 ​ 脱帽法：函数极限＞0，函数＞0 不证明可以直接使用 物理解释：当一个人跑到最远（位移最大），速度（位移的导数）为0；当一个人跑到最快（速度），其加速度（速度的导数）为0 导数零点定理又称达布定理 平均值定理 积分中值定理 开区间也成立 "},{"title":"步进电机相关知识点","date":"2020-03-12T01:12:41.000Z","url":"/2020/03/12/%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/","tags":[["嵌入式","/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"categories":[[" ",""]],"content":"1.RS232九针接口 引脚 定义 符号1 载波检测 DCD2 接收数据 RXD3 发送数据 TXD4 数据终端准备好 DTR5 信号地 SG6 数据准备好 DSR7 请求发送 RTS8 清除发送 CTS9 振铃提示 RI 2.max232芯片接口及作用 为什么要使用它从电脑的串行口过来的是rs232信号电平（-10 ，+10v），是负逻辑单片机只能接收正逻辑，TTL信号电平（0 ，+5）max232就是用来转换电平的   3.异步通信原理不带时钟同步信号在同步通讯中，收发设备上方会使用一根信号线传输信号，在时钟信号的驱动下双方进行协调，同步数据。例如，通讯中通常双方会统一规定在时钟信号的上升沿或者下降沿对数据线进行采样。 在异步通讯中不使用时钟信号进行数据同步，它们直接在数据信号中穿插一些用于同步的信号位，或者将主题数据进行打包，以数据帧的格式传输数据。通讯中还需要双方规约好数据的传输速率（也就是波特率）等，以便更好地同步。常用的波特率有4800bps、9600bps、115200bps等。 在同步通讯中，数据信号所传输的内容绝大部分是有效数据，而异步通讯中会则会包含数据帧的各种标识符，所以同步通讯效率高，但是同步通讯双方的时钟允许误差小，稍稍时钟出错就可能导致数据错乱，异步通讯双方的时钟允许误差较大。 3.晶振电路 步进电机，有一个很重要的参数——步距角——一个脉冲产生的转动角。以我有的四相五线步进电机为例给你说：这个步进电机的步距角为5.625度，这个步时电机带有减速器，减速比1：64，也就是说，一个脉冲信号，可以让电机的转轴，转动5.625/64度的角——2048次脉冲，就是180度。有了这个参数，就可以在程序中记录你发的脉冲次数，也就知道了转动过的角度，并保存在单片机的EEPROM中，掉电后也可以读出，那么就可以复原到初始位置了。不过，由于步进电机的步进角精度、失调角等等动态指标，会让电机转动的角度有误差，要调这个，我也没有经验，要更专业的人才行。 4.usb 5.自检专利"},{"title":"计算机网络两种模式区别","date":"2020-03-10T12:03:16.000Z","url":"/2020/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB/","tags":[["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[[" ",""]],"content":"**C/S (Client/Server)**客户端和服务器模式 常见的比如lol等客户端程序，需要下载客户端，客户端与服务器配合，可以满足需要大量数据交互的应用 优点： 可以对数据进行缓存，大的文件在下载客户端时就准备完成 运行时只要在第一次加载到主存，后面就能快速执行 可以自定义协议，不被固定的协议限制 缺点： 客户端不透明，用户安全可能存在隐患 开发需要客户端和服务端，开发量会大一些，联调很复杂 B/S（Browser/Server）浏览器和服务器模式 常见一些网页应用，比如网页版的qq，逻辑基本在服务器上实现，一般只适合数据量比较小的应用 bs的优缺点与cs相对"},{"title":"单链表的操作","date":"2020-03-09T07:36:58.000Z","url":"/2020/03/09/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/","tags":[["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[[" ",""]],"content":" 下面是单链表的操作，用c语言写的，可以和顺序表对应来看 结果 "},{"title":"小结2","date":"2020-03-09T05:44:28.000Z","url":"/2020/03/09/%E5%B0%8F%E7%BB%932/","tags":[["小结","/tags/%E5%B0%8F%E7%BB%93/"]],"categories":[[" ",""]],"content":"距离开始开始复习备考开始，已经进行了一个多月，进行下总结： 高数 目前，看了高数上册快一半了，函数极限，一元微分部分看完了，积分学开了一个头；主要是高数的基本知识，概念，花了很长时间进行了整理；做了部分习题，主要是张宇三十讲的章节习题，不过效果并不好，有点像在记答案，有时候题目换一下数据，就可能做不出来的，我思考得到了以下原因： 计算能力太差（有时候粗心导致） 听解题方法，并不知道为什么要这样做，知识没有融合起来，基本概念都知道，做题时就是不顺 我想了一些办法： 计算能力不强就多算，也想不到别的方法了 遇到不会的题先思考，模仿，实在不会再翻答案 一定要总结，这是后面想要着重培养的能力 英语 开始写复习计划时，订的计划是一开始就准备英语的；刚开始看词汇书，实在是背不下去，也是最近3月7号才开始的；这两天每天硬着头皮，花三个小时，背了五十个单词，发现其实也不是不能完成；出来混，迟早得还的，上了大学基本就没学过英语了，平常英语课都是水过的；英语的话我希望保持现在的状况，到了四月份开始看长难句 专业课 现在主要是在看数据结构，每天规定了，只看一个小时，以后再来增加时间；主要是怕复习基础这阶段完全不碰，到时候容易生疏（我已经发现大一学的c，有些地方已经记不清了）；学校也开了两门课，占用了一部分时间，作为拓宽视野，了解技术还是可以，重心还是应该放在四大基础课上 ( 数据结构，计算机组成原理，计算机网络，操作系统 ) 总结 过去的一个半月，还算比较满意，状态还可以；从开始的胡思乱想(年后还疯狂的玩了两个星期)，到现在能按计划来进行，进步很大，希望后面能保持这种状态；数学在做题目上要改进，英语和专业课按计划来，政治课到了七八月份再来看 分享一个拉格朗日定理 前提是函数在闭区间[a,b]连续，开区间(a,b)可导 如果用函数的增量表示高度的话，那么如果要使得 f(b)-f(a) (增量)尽可能地大(趋于正无穷)，那么就要控制f’(ξ)**或者(b-a)**,f’(ξ)是函数的变化率，(b-a)是区间的大小；函数增量趋于正无穷，则f’(ξ)，(b-a)两个必有一个趋于正无穷，另一个趋于常数；要么你的变化率趋于无穷，区间长度是一个常数，那么函数可以增到无穷大；要么你的变化率是一个常数，区间无穷大，最后依然能增长到无穷大；如果可以类比我们学习的话，考研还有九个月，时间是固定的；如果要达到考试认可水平，那么就得改变变化率，不断的改变，才有可能达到那个高度；当然，生活不能如此类比，但是好像也能从这得到一点启发 拉格朗日 "},{"title":"无法上网解决办法","date":"2020-03-07T13:48:59.000Z","url":"/2020/03/07/%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","tags":[["墙","/tags/%E5%A2%99/"]],"categories":[[" ",""]],"content":" 首先检查是不是自己网络的问题 关闭代理，看能否打开正常情况下可以打开的网站（比如github）；有的时候只能打开部分网站，另一部分网站打不开，也是本地网络商的问题，这时候重启路由就行 接下来检查服务器是否正常运行 先ping一下服务器的ip，看是不是通的；用ssh连接看是不是服务异常了；重启下看问题是不是解决；如果出现ping不通，有可能是ip被墙，被墙就只能换ip了；ssh连不上，可能是tcp阻塞（气不气，不封你IP，就是不让你看）； 如果上面都正常就检查一下域名解析是否正常，端口是不是被墙 一般晚上是高峰期，网就会很卡，可以开一个bbr加速（测试提速10倍） 解决办法： 换ip 换端口 再开一台服务器，做一个转发 "},{"title":"极坐标系下的图像","date":"2020-03-06T07:24:55.000Z","url":"/2020/03/06/%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%8B%E7%9A%84%E5%9B%BE%E5%83%8F/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"极坐标系(g(r,θ)=0) 心形线也叫外摆线，两个相同半径的圆，有一个圆固定不动，另一个圆围着固定圆转动，转动的圆上固定一点走过的路径就叫外摆线 r=a(1-cosθ) 玫瑰线 玫瑰线是极坐标系中的正弦曲线 r= asin3θ 阿基米德螺线 一个点匀速离开一个固定点的同时又以固定的角速度绕该固定点转动而产生的轨迹 r= aθ 星型线 内摆线，让一个半径为1/4的圆在一个半径为1的圆内部，沿着大圆的圆周旋转，小圆上固定一点走过的路径星形线 伯努利双扭线 用直角系观点表示极坐标图像先画出直角坐标系下的函数图像，通过初等函数图像变换（左加右减，上加下减少，横坐标1/k，纵坐标k倍，对称变换），通过直角坐标系下图像就很容易画出极坐标系下的图像 "},{"title":"AES对称加密算法","date":"2020-03-05T10:31:13.000Z","url":"/2020/03/05/AES%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["网络安全","/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"介绍高级加密标准(AES,Advanced Encryption Standard) 是一种对称加密算法；对称加密是指，加密、解密使用的同是一串密钥，只有一个密钥作为私钥 ；而非对称加密是加密、解密使用不同的密钥，公开的叫公钥，隐藏的叫私钥； 假设两方要加密通信数据，双方都知道对方的公钥，一方用对方的公钥加密，另一方用自己的私钥就可以解密 操作: 设C为密文，AES加密函数为E，K为密钥，P为明文，则 C = E(K, P) 设AES解密函数为D，则 P = D(K, C) AES加密算的4种操作： 字节替代（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 轮密钥加（AddRoundKey） AES加密不是一次成功，而是经过很多轮运算得到的 AES的Key有三种长度：AES128，AES192，AES256 除去初始轮，对应的轮数如下 AES128 AES192 AES256 10 12 14 初始轮只有一个步骤：加轮密钥 普通轮有四个步骤：字节代替、行移位、列混淆、加轮密钥 最终轮有三个步骤：字节代替、行移位、加轮密钥 这里以128位为例 流程图 步骤从流程图看得出，正向操作就是加密，反向逆操作就是解密 字节替代AES定义了一个S盒和一个逆S盒，字节代换就是一个查表操作 S盒 替换过程 16字节的明文块在每一个处理步骤中都被排列成4X4的二维数组 比如S1为0x12,则查S盒的第0x01行和0x02列，查表值为0xc9，替换 S逆盒 行移位 第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节 行位移逆运算就是方向向右，步长不变 列混淆 列混淆通过矩阵相乘实现 ：将矩阵b右乘列混淆矩阵 比如列混淆如上图，中间是混淆矩阵，右边是输入，左边是输出矩阵 这里的乘法不一样，第一行与第一列分别相乘，异或相加 02·S0,0 03·S0,1 01·S0,2 01·S0,3 对应二进制乘法，假设结果为a b c d 那么输出第一行第一个为 a xor b xor c xor d 依次得到第一行第二列异或和对应输出第一行第二个 ··· 第四行第四列异或和对应输出第四行第四个 逆变换矩阵同正变换矩阵的乘积恰好为单位矩阵 轮密钥加 将128位密钥K排成4X4的矩阵 ，那一格就有128/16=8位 a0,0 与 k0,0异或得到输出， 让输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j] 轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身 参考 AES加密算法的详细介绍与实现 AES加密算法之字节替换操作 AES算法字节代换，行移位，列混淆，轮密钥加之例题详解+代码实现 漫画：AES 算法的底层原理 "},{"title":"vs code常用快捷键","date":"2020-03-04T12:35:23.000Z","url":"/2020/03/04/code%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","tags":[["vs code","/tags/vs-code/"],["快捷键","/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"]],"categories":[[" ",""]],"content":"vs code有一部分快捷键和eclipse是一样的，下面是一些常用的 快捷键 作用 Alt+Up/Down 移动当前行上下 Shift+Alt+Up/Down 在当前行上下复制当前行（有的应用比如网易云会占用这个快捷键，禁用全局模式就行） Ctrl+Shift+[ 折叠区域代码 Ctrl+Shift+] 展开区域代码 Ctrl+/ 添加关闭行注释 Ctrl+G 跳转行 F8 跳转到下一个错误或者警告 Ctrl+F 查询 Ctrl+H 替换 Ctrl+Shift+N 打开新窗口 Ctrl+N 新建文件 Ctrl+B 切换侧边栏显示隐藏 Ctrl+Shift+V Markdown预览切换 Ctrl+Shift+P 启动搜索框 "},{"title":"顺序表的操作","date":"2020-03-04T11:47:30.000Z","url":"/2020/03/04/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/","tags":[["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[[" ",""]],"content":"手写了一个顺序表的操作，复习了一下c语言的相关知识；在操作指针时，一定要谨慎，特别是在结构体中，因为连续的地址，容易错误修改临近值，产生一个莫名其妙的bug；每次向系统malloc了资源，要还给人家，有借有还，再借不难； 结果 "},{"title":"中值定理","date":"2020-03-04T02:22:04.000Z","url":"/2020/03/04/%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"关于函数的有界与最值定理若f(x)在[a,b]上连续，则存在实数m和M，使得：m≤f(x)≤M(m,M分别为最小值和最大值) 介值定理若f(x)在[a,b]上连续，当m≤μ≤M，则存在ξ ∈[a,b] ,使得f(ξ)=μ (平均值定理)当a&lt;x1&lt;x2&lt;···&lt;xn&lt;b时，在[x1,xn]至少存在一点 ξ ，使 零点定理若f(x)在[a,b]上连续，且f(a)·f(b)&lt;0,则存在ξ ∈**(a,b)** ,使得f(ξ)=0 关于导数的5费马定理 设函数f(x)在x0处满足： 可导 取极值 则f’(x0)=0 罗尔定理 设函数满足以下三个条件： f(x)在闭区间[a,b]上连续 f(x)在开区间(a,b)可导 f(a)=f(b) 则存在ξ∈(a,b) ，使得f’(ξ)=0 f(x)在闭区间[a,b]连续是必须的，否则有可能没有f’(ξ)=0 拉格朗日中值定理 设函数满足以下三个条件： f(x)在闭区间[a,b]上连续 f(x)在开区间(a,b)可导 则存在ξ∈(a,b) ,使得 柯西中值定理 设函数f(x),g(x)满足以下三个条件： f(x),g(x)在闭区间[a,b]上连续 f(x),g(x)在开区间(a,b)可导 ∀x∈(a,b),g’(x)≠0 则存在ξ∈(a,b) ,使得 泰勒公式如果函数f(x)在x0的某个邻域U(x0)内具有n+1阶可导，则对该邻域内任意一点，有 ξ介于x0与x之间 关于积分的1积分中值定理若函数f(x)在[a,b]上连续，则存在 ξ ∈[a,b] ，使得 "},{"title":"数组越界导致的数据异常","date":"2020-03-03T23:54:42.000Z","url":"/2020/03/04/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BC%82%E5%B8%B8/","tags":[["报错","/tags/%E6%8A%A5%E9%94%99/"],["c","/tags/c/"]],"categories":[[" ",""]],"content":"写了一个顺序表插入的demo,结果显示异常 输出 这个异常就很莫名奇妙，期望的结果应该最后一栏，结构体的length长度应该是10，结果却是1；从输出可以看到，前9项都正常，最后一项，很诡异，9自加1得1 分析 我插入的方式是，统一是把要插入的这个点以后的全部的数据全部后移一格，腾出一格插入数据 结构体的内存图 length应该是跟在数组后面，程序实际上是把data[9]赋给了data[10]，而data[10]已经越界了，data[10]就是length，虽然越界了，但指针还是能这样操作；就是把数组最后一个0付给length，然后0+1=1;就看到了这样的输出结果进调试查看一下位置 和预想的一样，通过检查，发现循环检测的条件不对，当index==L-&gt;length时，循环应该跳出，不应该进行操作;修改为 验证 得到正确结果"},{"title":"一元函数微分学几何应用二","date":"2020-03-03T09:28:49.000Z","url":"/2020/03/03/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8%E4%BA%8C/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"渐近线铅垂渐近线当x趋于一点x0时，函数极限是无穷，则x=x0为函数的铅锤渐近线 铅垂线不一定是无穷间断点：间断点是一个过程，需要两边都有趋向的过程，铅锤线可以在一侧无定义 水平渐近线当x趋于正无穷或负无穷时，函数极限为常数y0，则y=y0为函数的水平渐近线 水平渐近线不会和斜渐近线在一个方向 斜渐近线当x趋于正无穷或负无穷时，函数比上x是同阶的为k的，且f(x)-kx极限存在为b,则y=kx+b为函数的斜渐近线 当x趋于无穷时，函数趋于无穷就有可能存在斜渐近线 求函数渐近线的过程 最值与最值范围闭区间连续必有界 开区间[a,b]求出拐点，不可导点，区间端点的函数值，比较得到最值 闭区间(a,b)求出拐点，不可导点，区间两端单侧极限的函数值，得出取值区间 函数图像 确定定义域 确定奇偶性，对称性周期性 令函数一阶导，二阶导为0，求x的分区间 确定渐近线 画图 复合函数f(g(x))的奇偶性:内偶则偶，内奇外同"},{"title":"一元函数微分学几何应用","date":"2020-02-29T11:14:11.000Z","url":"/2020/02/29/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"三点两性一点 一.极值和最值的概念定义极大值: 若对点x0的某个邻域内所有x都有f(x)≤f(x0)，则称f(x0)是f(x)的广义极大值 若对点x0的某个邻域内所有x都有f(x)&lt;f(x0)，则称f(x0)是f(x)的真正的极大值 最大值： 存在实数M，对于任意实数x∈I，都有f(x)≤M，则实数M 是函数y=f(x)的最大值 极值与最值的关系一般说，极值是局部的，最值是整体的；极值点不一定是最值点，最值点不一是极值点 若函数在区间内一最值点不为端点，则此点是一个极值点 极值与间断点的关系间断点可以是极限点 二.单调性与极值的判别单调性判别 若函数y=f(x)在区间I上有f’(x)&gt;0，则称函数在区间I上严格单调增加； 若函数y=f(x)在区间I上有f’(x)&lt;0，则称函数在区间I上严格单调减少; 一阶可导点是极值点必要条件 f(x)在x=x0处可导，且在x0处取极值，则导数f’(x0)必为0 反例y=x^3 判别极值第一充分条件 设函数f(x)在x=x0处连续,且在x0的去心邻域内可导 若xϵ(x0-δ,x0) ，f’(x0)&lt;0,而xϵ(x0,x0+δ) ，f’(x0)&gt;0,则f(x)在x=x0处取极小值 若xϵ(x0-δ,x0) ，f’(x0)&gt;0,而xϵ(x0,x0+δ) ，f’(x0)&lt;0,则f(x)在x=x0处取极大值 若f’(x0)在(x0-δ,x0) 和(x0,x0+δ) 内不变号，则点x0不是极值点 判别极值第二充分条件 f(x)在x=x0处二阶可导(n≥2)，且f’(x0)=0,f’’(x0)≠0 若f’’(x0)&lt;0,则f(x)在x=x0取极大值 若f’’(x0)&gt;0,则f(x)在x=x0取极小值 证明 判别极值第三充分条件 f(x)在x=x0处n阶可导(n≥2),前n-1项导数都为0，第n阶导数不为0 若n为偶数，且n阶导数小于0，则f(x)在x=x0取极大值 若n为偶数，且n阶导数大于0，则f(x)在x=x0取极小值 三.凹凸性与拐点的判别凹凸性定义 设函数f(x)在区间I上连续,如果对I上任意两点x1，x2，恒有 则f(x)在I上的图形是(向上)凹的 如果恒有 则f(x)在I上的图形是(向上)凸的 拐点定义 函数曲线的凹凸分界点 四.凹凸性与拐点的判别判断凹凸性 设函数f(x)在I上二阶可导 若在I上f’’(x)&gt;0,则f(x)在I上的图形是凹的 若在I上f’’(x)&lt;0,则f(x)在I上的图形是凸的 二阶可导是拐点必要条件 设f’’(x0)存在，且点(x0,f(x0))为曲线上的拐点，则f’’(x)=0 判断拐点第一充分条件 设函数f(x)在x=x0处连续,且在x0的去心邻域内二阶导数存在 若该点处左右邻域内f’’(x0)异号，则点(x0,f(x0))为曲线上的拐点 判断拐点第二充分条件 设f(x)在x=x0的邻域内三阶可导，且f’’(x0)=0，f’’’(x0)≠0，则点(x0,f(x0))为曲线上的拐点 判断拐点第三充分条件 设f(x)在x=x0的邻域内n阶可导(n≥3)，前n-1项导数都为0，第n阶导数不为0 则当n为奇数时，点(x0,f(x0))为曲线上的拐点"},{"title":"一元函数可导·可微·极限存在·连续概念整理二","date":"2020-02-26T00:38:18.000Z","url":"/2020/02/26/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%8F%AF%E5%AF%BC%C2%B7%E5%8F%AF%E5%BE%AE%C2%B7%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%C2%B7%E8%BF%9E%E7%BB%AD%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86%E4%BA%8C/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"1.若函数可导，求导后奇偶性互换 2.若函数为周期为T的函数，求导后导函数也为以T为周期的函数 3.微分记法 4.补充 5.高阶导数 反函数二阶导公式 隐函数二阶导公式 6.用幂指函数求导公式时，要恒等变形，不要忽略定义域；对数求导可以视绝对值不见 6.单调函数必有反函数 f’(x)≠0，f’(x)保号 用中值定理证明 7.泰勒展开三部曲 麦克劳林 步骤 按公式展开 取对应的系数 根据泰勒展开的唯一性，确定系数 8.数学归纳法 "},{"title":"线性表概念","date":"2020-02-25T06:07:27.000Z","url":"/2020/02/25/%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%A6%82%E5%BF%B5/","tags":[["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[[" ",""]],"content":"基本概念前驱：逻辑上前一个结点 后继：逻辑上后一个结点 线性表特点： 存在唯一一个被称为第一个元素的数据元素 存在唯一一个被称为最后一个元素的数据元素 除开第一个数据元素，其他数据元素均只有一个前驱 除开最后一个数据元素，其他数据元素均只有一个后继 线性表：n个数据元素有限序列 线性表顾名思义，‘’用线穿在一起的表‘’，从开始到结束，one by one; 如单链表 顺序存储结构和链式存储结构从逻辑上看线性表的数据元素之间是“一对一”关系，从存储方式上看分为了顺序存储和链式存储 借用网上的图地址就能很好的看出它们得到区别： 顺序存储是连续的内存空间，链式存储并非一定要在连续内存空间 操作对比 操作 顺序存储结构 链式存储结构 创建 简单，申请一段连续内存 较简单，需定义结点等 增加 新建一段足够的连续内存，把旧数组存入 方便，通过指针连接新的添加数据 删除 把要删除的数据后面的数据前移覆盖 修改要删除的链表数据的前一个的变量的指针 修改 通过索引修改数据 遍历数组修改 查询 通过索引查找，速度快 遍历数组查询，速度较慢 注：这里有两种操作，头插法和尾插法，其实就是存储的顺序不同；头插法是后来的数据从头部插入，尾插法是后来的数据插到尾节点后；其实没有什么不同，不必纠结选哪种，就好像吃鸡蛋从大头或小头打一样 如果它们同时插入12345（示例Graphviz 使用的bot语言） 头插法 尾插法 "},{"title":"添加播放器","date":"2020-02-24T02:12:26.000Z","url":"/2020/02/24/%E6%B7%BB%E5%8A%A0%E6%92%AD%E6%94%BE%E5%99%A8/","tags":[["播放器","/tags/%E6%92%AD%E6%94%BE%E5%99%A8/"]],"categories":[[" ",""]],"content":"我的博客使用的下项目：APlayer 项目目录 我们只需要dist文件里的css和js，把dist复制到hexo主题的模板文件中，比如我的路径是：G:\\blog\\themes\\replica\\source\\dist 配置music.js进入dist，这里还需要对播放列表，模式等进行配置，APlayer是通过脚本控制播放的；新建一个脚本music.js,配置代码如下 url可以写网络路径，也可以把你放的背景音乐下载到source内；填你的本站路径，当然如果想添加比较多的话就不建议这么做；配置不懂的可以去查官方文档 添加到网页加下列代码添加到模板中，完成 缺点添加一两首音乐还可以，如果要添加一个列表还要一条条添加就显得不够优雅，可以考虑写脚本自动生成对应的配置代码"},{"title":"数据结构","date":"2020-02-23T09:56:36.000Z","url":"/2020/02/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","tags":[["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[[" ",""]],"content":"前言 数据结构对于计算机专业来说，算是基础课；可惜在学的时候，并没有学好它；一是重视不够，二呢就是练习的少；好在现在我开始重视这门课了，决定补习一下，好好把知识再过一轮，再多加练习；我参考的专业书是【大话数据结构】和严蔚敏的【数据结构(c)】，都是口碑很好的书；参考的项目地址Mzzopublic/C；不记得那本书上写了 –“了解细节是理解概念的先决条件”；今天开始开这一栏，每天大概花一个小时来整理，不求速度，重在理解 对比刚开始整理，把两书对比下 严蔚敏的【数据结构(c)】 【大话数据结构】 第1章 绪论 第1章 数据结构绪论 第2章 算法 第2章 线性表 第3章 线性表 第3章 栈和队列 第4章 栈与队列 第4章 串 第5章 串 第5章 数组和广义表 第6章 树和二叉树 第6章 树 第7章 图 第7章 图 第8章 动态存储管理 第9章 查找 第8章 查找 第10章 内部排序 第9章 排序 第11章 外部排序 第12章 文件 严书分了十二章，大话分了九章(你那个目录里面写一大堆话是什么骚操作，我截目录时翻了半天···)；严书的动态存储管理和文件这两张章是大话没有的，这两张涉及了部分操作系统的知识；整体看上去，两本书可以很好的对应； 数据结构绪论1946年2月14日，世界上第一台电脑ENIAC诞生，美军方将他用于导弹轨道计算；计算机一路发展，给人们的生活带来翻天覆地的变化；数据结构就在此不断发展 基本概念数据：是客观事物的符号表示，是能被输入到计算机并能被计算机处理的符号总称 数据元素：数据的基本单位 数据项：一个数据元素可以由若干项数据项表示 数据对象：性质相同的数据元素集合，是数据的一个子集 整理了一下，看这个图，就感觉在看关系数据库，这里的一个数据对象就是一张表啊，存储不同的数据元素，而每个数据元素单独又是一张张独立的表，表里有不同的属性（数据项）；若干项数据项组成了数据的基本单位——数据元素，若干数据元素组成一个数据对象，数据是实体的抽象；这里要补充一下数据库的观点，并不是所有的实体（理解成事物）都可以抽象成数据的；这个数据是相对应的概念，取决于你需要解决的问题；比如我们需要知道班级中年龄最大的那个人，我们只需要得到每个人的年龄抽象的数值数据；而这个人的身高信息，从数据关系上说，是这个人（数据元素）的一个数据项；但对于解决谁年龄大这个问题，身高是无关的，所以身高不必抽象成数据 数据结构数据结构：存在一种或多种特定关系的元素的集合 从不同方面看会有不同的分类： 逻辑结构解决了不同元素之间的关系问题，让解决问题的方案在逻辑上无误；存储结构则解决了怎么让计算机理解处理的问题；理解上，前者是人思考的问题，后者是计算机的过程；辅以相应的操作配合（插入，删除，优化算法提高效率···），这些操作沟通了人和计算机；最终，这三类相互配合，达到处理问题的目的 逻辑结构 集合——数据元素之间除了同属于一个集合外，没有其他关系线性——数据元素之间是一对一的关系树形——数据元素之间存在一对多的层次关系图形——数据元素之间存在多对多的关系 存储结构（物理结构） 数据类型一组性质相同的值的集合及定义在此集合上的一些操作的总称 类型，指明了变量或表达式的取值范围和所能进行的操作；有的语言是强类型语言（如c），有的是弱类型语言（如JavaScript），强弱之分就是是否严格规定了类型； C语言中，按照取值的不同，分为 原子类型——不可再分的基本类型，如int，float，long 结构类型——由若干类型组合而成，struct，union 抽象数据类型：通常由用户定义，用以表示应用问题的数据模型以及定义在该模型上的一组操作，ADT=（D，S，P） （D是数据对象，s是D的关系，P是D的操作） 实际上，结构体可以看作是对基本类型的补充，对于你要解决的特定问题，你可以自定义结构体得到一种类型；结构类型和抽象数据类型的区别就是：结构只包含数据和关系，抽象数据增加了操作；对于抽象数据类型，就好像看到了java的类的样子，类包含属性和方法，属性对应抽象数据类型的不同类型，方法对应不同的操作，有异曲同工之妙；但它们实际不同，前者是过程式语言，自底向上；后者是面向对象的语言，自顶而下，其中的思想是不同的 存储方式 顺序存储——把数据元素放在地址连续的存储单元里，数据间的逻辑关系与物理关系一致链式存储——把数据结构存放在任意的存储单元里，可以是连续的，也可以是不连续的 顺序存储最简单的例子就是数组了，数组是一段连续的内存，顺序存储；链式存储的一个例子单链表，可以存在不连续的内存上 算法特征： 有穷：执行有限步骤后，自动结束而不会出现无限循环 确定：每一步骤都具有确定含义，不存在二义性 可行：每一步都在有限次数内完成 有输入和输出 要求： 正确性——输入、输出、加工处理无歧义性，能正常反映问题的需求、能得到问题的正确答案 可读性——便于阅读、理解、交流和维护 健壮性——当输入数据非法数据能抛出异常而不至于输出莫名其妙的值 时间效率高和存储量低 算法衡量 方法有事前分析法和事后统计法 衡量标准有时间复杂度和空间复杂度"},{"title":"一元函数可导·可微·极限存在·连续概念整理","date":"2020-02-22T08:47:49.000Z","url":"/2020/02/22/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%8F%AF%E5%AF%BC%C2%B7%E5%8F%AF%E5%BE%AE%C2%B7%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%C2%B7%E8%BF%9E%E7%BB%AD%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"整理一下一阶函数的的概念 可导和可微是等价的 证明这个用到了函数极限的等式脱帽法 证明 可导必连续 反过来，连续不一定可导，记一个例子，y=|x| 连续必极限存在 由连续定义可得 闭区间连续必有界，有最值 注意这个要求是闭区间[a,b] 极限存在必有界 反之不成立：y=sinx 给定条件函数(a,b)连续,要证明有界：即要证明区间端点也连续，中间连续加两边连续，整个连续，区间有界 补充：f’(x)在区间(a,b)上有界,则函数必有界 "},{"title":"墙","date":"2020-02-22T02:22:39.000Z","url":"/2020/02/22/%E5%A2%99/","tags":[["墙","/tags/%E5%A2%99/"]],"categories":[[" ",""]],"content":"最近由于疫情原因，国内gfw越来越高，有好多ssr机场都沦陷了；城门失火，殃及池鱼；最近torjan好像特别火，Trojan把Trojan服务器伪造成Nginx，trojan将流量伪装成常见的https流量，墙不会对大量的http进行甄别；下面记录下步骤 1.申请域名，域名解析 2.购买vps 3.部署Nginx服务器 4.部署Trojan 5.本地配置 关于翻墙的小伙伴：墙外不是不法之地，翻墙后不参加政治斗争，不留评论，不浏览有害信息；国外媒体的一些言论，理性去看待，不要被带路党带偏了，其目的到底是是什么，要想清楚；我们国家在某些方面，确实有不足，但是依然不妨碍去爱这个国家；我相信这些都会改善；而那些捧杀，诋毁的人不是真的蠢就是坏"},{"title":"手机安装谷歌服务框架","date":"2020-02-19T14:23:47.000Z","url":"/2020/02/19/%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85%E8%B0%B7%E6%AD%8C%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/","tags":[["google","/tags/google/"]],"categories":[[" ",""]],"content":"做个记录 1：下载安装应用汇(华为系列手机需要关闭开启外部检查才能安装GMS安装器) 2：在应用汇里下载GMS和GO谷歌安装器或者谷歌安装器167.27k的那个版本。 3：华为系列手机先安装GMS安装器，再安装GO谷歌安装器。 4：小米以及其他系列的手机直接安装谷歌安装器167.27k版本。"},{"title":"seo优化","date":"2020-02-19T02:20:37.000Z","url":"/2020/02/19/seo%E4%BC%98%E5%8C%96/","tags":[["hexo","/tags/hexo/"],["blog","/tags/blog/"]],"categories":[[" ",""]],"content":"SEO (Search Engine Optimization ) 中文意“搜索引擎优化” 优化一是对站内排版进行 SEO 的优化，二就是对搜索引擎的主动的优化 提交站点1.安装sitemap插件 2.配置_config.yml 的 url 为站点地址 生成 sitemap.xml 文件（搜索引擎通用文件）提交到站点 最好检查一下能否访问sitemap.xml，比如我的路径为 3.新建 robots.txt 文件在根目录 source 文件下新建 robots.txt 文件,配置爬虫文件（浏览器其实就是爬虫） 4.减少垃圾链接nofollow 标签是“反垃圾链接”标签；用于指示搜索引擎即抓取网页上的带有 nofollow 属性的 任何出站链接,减少垃圾链接的分散网站权重 一般出站连接主要是一些友情连接，集中在footer，注意下在a标签下增加 rel=”external nofollow”即可 完成了上面四项一定要hexo d -g提交，要不然后面Google在抓取(索引)的时候会失败 5.提交网站google 站长，进入登录谷歌，添加网站 之后验证网站，按提示来； 6.提交站点地图 提交后若成功可以在下面看到状态 7.抓取点左边的网址检测，这时没有索引，点击右下申请索引，等待两三分钟就可以了 8.测试输入 site:域名，测试一下，成功 "},{"title":"gitalk插件添加","date":"2020-02-18T15:52:34.000Z","url":"/2020/02/18/gitalk%E6%8F%92%E4%BB%B6%E6%B7%BB%E5%8A%A0/","tags":[["hexo","/tags/hexo/"],["报错","/tags/%E6%8A%A5%E9%94%99/"]],"categories":[[" ",""]],"content":"今天更行了博客gitalk插件，记录如下 安装步骤1.创建一个新仓库这个仓库用来存放评论 2.申请一个OAuth application给Gitalk权限，更改仓库内容 申请信息 注册完成后会有一个ClientID和ClientSecret，这是我们需要的信息 3.在_config.yml中配置由于我的主题中已经写好了gitalk，就不需要安装，只要配置一下就行了 配置参数 遇到的问题 开始都配置好了，可以运行了，前端可以显示，但一直报Error: Bad credentials. 去谷歌了一下，只找到了一篇关于这个错误的；他的解决办法是加上引号，我就试着改了几下，问题依然没有解决 我点了一下使用GitHub登录，界面跳404了；这时我发现他的网址栏是这样的 client_id这一项的参数是未定义的；我会过头来看我的配置，检查了一下，没发现问题；我觉得有可能还是引号的问题，有可能我多打了引号他识别出错；我就查了他给赋值的代码 代码中已经把引号都加上了，表示字符串，所以我确定，在配置里，我都不用写引号；代码是正确的，配置中也写了，但结果是未定义的； 最后经过一个多小时的检查，发现问题是出在配置上；我发现我的配置文件里是clientID，而我脚本里面对应的是client_id；我写配置的时候是直接copy网上的代码，结果这时翻译开着在，复制过来的是中文； 修改后，正确的进入了初始化 修改后又遇到了另一个问题 Error: Validation Failed这个错误的原因是issue的名字不能超过50 参考文章 新建一个md5.min.js 在gitalk.ejs引入脚本，并设置id 经过一番努力最后终于解决了问题"},{"title":"js特效","date":"2020-02-18T12:33:32.000Z","url":"/2020/02/18/js%E7%89%B9%E6%95%88/","tags":[["hexo","/tags/hexo/"],["js","/tags/js/"]],"categories":[[" ",""]],"content":"搬运两种js特效樱花源地址 点击生成爱心 love "},{"title":"使用Google自定义搜索","date":"2020-02-17T03:46:54.000Z","url":"/2020/02/17/%E4%BD%BF%E7%94%A8Google%E8%87%AA%E5%AE%9A%E4%B9%89%E6%90%9C%E7%B4%A2/","tags":[["blog","/tags/blog/"],["google","/tags/google/"]],"categories":[[" ",""]],"content":"Google自定义搜索引擎（Google Custom Search Engine）官方文档 Google的设置添加一个自定义搜索 把代码放到博客对应的地方 按需要配置 最简单的就实现了 问题：如果不翻墙，搜索速度很慢或着根本上不去(我真感谢GW)··· 如果想要搜索博客内内容需要和配合googleApi"},{"title":"hexo博客优化","date":"2020-02-16T11:20:13.000Z","url":"/2020/02/16/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/","tags":[["hexo","/tags/hexo/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":"今天，终于对hexo博客进行了优化，从早上八点一直改到晚上七点；上午的时间基本在让新版本跑起来，下午则在改一些细致的东西；期间把源码基本看了一遍，有一些问题值得记下来 这里要感谢小姐姐@ Hiitea分享的Replica，我对Replica进行了一些改动；我删去了categories，只留下了tags； 历史版本： 这也是我喜欢的一款，主题是aircloud，十分简洁，我最喜欢的是它的归档，是以时间轴竖向的排列方式； Replica版也就是现在的版本，github风格，他的排版，颜色我都很喜欢 记录我是用的git+hexo+markdown+github搭建的个人博客；用git进行代码管理，hexo是博客框架，基于node.js,markdown是用来写文章的，类似记事本，github上的个人仓库相当于服务器；写好文章后，git提交github，其他人访问我的博客只要访问github的服务器就行了；本身没有后台和数据库，都在本地，所以很安全，方便，维护也简单；免费，而且易于实现，对于我们这种学生党，简直太好了；同时也有缺点，就是速度慢（访问国外服务器肯定会慢一些），而且不好做seo优化（因为很多github的服务器屏蔽了百度，哈哈哈），好在我也并不打算做优化··· hexo目录结构 _config.yml hexo切换主题其实也不算难，比较繁琐的可能是写_config.yml配置 我就截取了部分；一般要配置一些标题啊，作者，语言等等；一些路径也是可以填在这的，比如你的头像，你放在hexo上，就填上图片的相对路径就好；特别要注意YAML的语法,“：”后面有空格 官方文档 package.json 记录版本信息，hexo框架的参数，hexo需要的插件等等 scaffolds 这是个文件夹，我理解的这是存的是模板，比如你hexo new xx一篇文章，生成的文章就以这个文件里的模板自建一个，帮你填好一些信息，比如文章名，创建时间 source 这个是放资源和文件的地方，比如_posts里面有新建的文章和资源文件夹，个人写的.md文档放这里 themes 存放主题文件,比如我的主题Replica文件目录 一般layout是放的模板，比如ejs文件，更改这些文件就相当于在改前端页面，我没有学过这门语言，但我跟浏览器给我的信息就能猜个大概，有点js，java的意思 .gitignore 这个存的是和git相关的，hexo d -g上传时钩子忽略上传的文件 public 通常，如果你编译以后会生成这个文件；hexo把md文档编译成静态网页，存放在里面（一般还有你的资源啥的，比如图片）；当你本地运行时，就是打开的这个文件；如果你hexo clean了，那么删除的也是这个文件 .deploy_git 这个文件就是用来上传到github的文件了 生成文档时同时生成资源文件夹只要在_config.yml配置 图片在网页上无法显示在换主题的时候，我遇到了这个问题，我检查了图片路径，ejs里面地址定向，最后发现是插件的问题；Hexo上传的图片在网页上显示是要插件的，但是我改主题以前，都能正常的显示，但是换了主题之后就不能用了，这个问题让我很困惑，按理说它们之间应该联系不大的；最后，确实是重装之后，解决了问题 路径问题这个也处理了很久，我第一次在_config.yml配置的时候写的是相对路径（因为我在使用aircloud时，就是写的相对路径，估计他的layout里面也没改变路径） 这是我当时的文件目录 这是图片avatar.png    当时的情况就是点击overview，图片正常显示，然后点击post和tags图片显示异常 当时并没有去查图片的路径，我觉得可能是局部刷新那里的问题，也许是刷新的时候错误的关闭了变量导致不能访问，这时只要在刷新的时候加载一下图片就行 最后发现，图片指向的路径点的时候就变了，不是我认为的这里的avatar.png实际上是三个不同地方的图片，我只有第一个路径下有图片，第二个第三个没有，当然就显示异常了；这里如果要在这三个地方用一张图片就有几种办法，第一是去改源码，把三个地方的路径改成同一个；第二个就是在配置的时候填绝对路径；最后就是三个路径都给他建起来； 这里的经验：以后在debug时，先要确定到底出错的原因是什么，顺腾摸瓜，去找问题；不能漫无目的的去猜，比如这次要是我一开始就去检查路径正不正确，直接就会知道是配置的问题，就不会浪费大量的时间（今天都没时间看高数了···） 三目运算上学的时候都学过三目运算 ？：；都知道是什么意思，如果要自己写这种逻辑就是直接if···else去了，Replica这个项目基本上都是用的三目运算代替ifelse语句 目的呢是为了压缩代码；网页访问是追求速度的，同样的逻辑代码，我的比你的代码量少，那么我就先传输完；这种提升，从小的对比可能效果不大，但是在网上，一旦这个网页浏览量上来了，这个提升就很可观了 日期处理类库Moment.js官方文档 显示更新日期 显示距今多久 "},{"title":"极限替换错误","date":"2020-02-15T05:23:25.000Z","url":"/2020/02/15/%E6%9E%81%E9%99%90%E6%9B%BF%E6%8D%A2%E9%94%99%E8%AF%AF/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"],["数学错题","/tags/%E6%95%B0%E5%AD%A6%E9%94%99%E9%A2%98/"]],"categories":[[" ",""]],"content":"例子今天做过的两道题，通过错误示范，加深了对极限替换的认识 第一题,过程和结果正确 刚开始做第一题时，我看见有e^x,就想配一个1出来用等价无穷小替换e^x-1 ~x,然后看到前面的x，正好提一个x出来，后面就是重要极限，为1， 第二题,这是我第一次做的错误过程 做第二题的时候，和第一题类似，用等价无穷小替换cosx-1 ~x，顺着推，就得到1结果；看起来好像没问题，实际上是错的；通过查资料，仔细研究，我发现错误的原因是精度不够 重要界限没有错，错的地方在于带入，应该把三次方的项也带进去，这里可以看泰勒公式 为什么要把三次方也带进去，因为它的分母是二阶的，sinx/x展开后，如果有二阶的项，也会影响最后的结果；所以按原来的思路应该改成下面这样 这次结果就正确了；想起来以前上高数课时，老师似乎说过，不能在加减法中用无穷小等价替换；现在看来，好像也可以换，只要把握好精度；张宇课上说，老师不让用是为了保护我们，不让我们算错；这样解释好像也有道理； 对泰勒的理解泰勒公式本质上就是当x趋于x0时，用x0点的值不断去逼近它；利用指数函数的导数是本身的特性，用不的阶数去划分它们变化的速度(比如在一个变化过程中,a趋于一个值的速度比b趋于零的速度快，就说a比b高阶无穷小)，当泰勒展开阶数越高，后面的佩亚洛余项o(x)也就越小；当o(x)小到可以忽略不记的时候，泰勒不断逼近的这个值就越接近原函数的值，这个时候可以看成函数原本的值；怎么写着写着就像在写微分的意义了，微分就是如果函数可以写成f(x)=A∆x+o(x)的形式(A是与∆x的无关的常数)，则称A∆x为f(x)在点x0处的微分；微分是用简单量代替复杂量，实际上也不是函数点x0本来的值，但是这个误差可以忽略不记；这就是极限，无限逼近 泰勒公式从根本上阐述了无穷小等价替换的本质。什么时候进行怎样的等价替换？该不该增加这些项？无穷小等价替换不唯一……..都可以通过泰勒公式给予强有力的解释 我只想说，泰勒牛啤；不用一直洛洛洛····，而且有时候还失效 补充：非零因子代入（局部极限带入）设f(x),g(x),在x0的邻域内有定义，当x趋于x0时，f(x)极限存在为A且A不为0，则 原则 整体乘积 该因子极限不能为0 逻辑 "},{"title":"小结1","date":"2020-02-14T17:18:23.000Z","url":"/2020/02/15/%E5%B0%8F%E7%BB%931/","tags":[["小结","/tags/%E5%B0%8F%E7%BB%93/"]],"categories":[[" ",""]],"content":"​ 昨天去淘了一些考研经验贴，看了之后，针对自己情况做了计划；不想到半夜了怎么也睡不着,很烦躁；本来想着十二点睡，结果越想人越清醒，真郁闷；我想实在不行就起来写点什么，随便更新下博客，于是就有了这篇文章；名字我都没想好，也不好做分类；我估摸着以后可能还会写，就直接用小结加序号命名了； ​ 从十号到今天十五号，基本每天都是十一点半上床，要到一点多才睡得着，实在没办法了；就去知乎找别人借经验；结果一搜，哈哈，下面是一位答主的作息 跟我一样，也是睡不着；果然是众生皆苦；睡不着，我也知道是有点焦虑了；但是换个角度，说明我确实是很重视考研这件事，期望越高也就越害怕失败嘛；所以有焦虑是正常的；下一步就是要做到按作息休息；我觉得可以把想法写下来，然后自我积极暗示； ​ 最后对近段时间的学习做个总结；从一月七号放假开始，到一月二十三过年，我基本在看张宇的基础三十讲和专业课的内容；宇哥的第一章是基础知识，很杂，有很多都是高中内容，说实话，很长时间没见，好多都忘了，当时统一过了一遍，龟速；而且还有一部分新的高数知识是作为基础知识的，还要我学习，比如有笛卡尔的心形线，伯努利双扭线等等；基本上第一章我是慢慢硬啃下来的；看一点高数，实在看不进去了就做点别的；那几天我装了c和java的运行环境，准备给博客增加评论系统失败了，还装了双系统，然后又把步进电机的项目推进了一点，回来和家乡的小伙伴聚了会；过年前节奏不是很快，基本上学一点就玩半天；到了过年那几天，疫情越来越严重，我们回老家过年后就封路了，我就在老家玩；基本我从过年一直玩到二月七八，差不多两个星期没有看高数，因为lol出无限火力了，我就去快乐去了，那几天我记得就只看了一点cpu平台知识和linux命令；现在有点后悔玩这么长时间了，少玩两三天也好；八号开始我就决定要开始好好复习了，刚开始有点慢，后来有了节奏；看视频学基础知识，然后整理到博客里面，一气呵成；通过这几天的学习，现在写一个证明，刷刷几条公式写下来很舒服；我原来还打算每天都更新博客，整理知识点，但是我发现这样不行；学一个知识点很快，但是把知识融会贯通还是很难的，所以也不必更的很勤；13号我就大致把知识点整理到第四章了，14号我才把第二章数列极限习题全部做了一遍，证明了一些定理，第三章函数极限系统快做到一半了；速度看起来慢，但我已经很满意了；从现在一直到暑假的目标就是把教材过一遍，完成第一轮的复习，打好基础；我想多花一点时间在基础上，俗话说，基础不牢，地动山摇，我想夯实基础，现在基础扎实一点，后面就轻松一些；另外，专业课教材要开始通读；英语单词，长难句也要跟上开始记； ​ 放平心态，打好基础，奥力给@@@"},{"title":"navicat连接mysql报错:1251","date":"2020-02-13T11:13:45.000Z","url":"/2020/02/13/navicat%E8%BF%9E%E6%8E%A5mysql%E6%8A%A5%E9%94%99-1251/","tags":[["报错","/tags/%E6%8A%A5%E9%94%99/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"categories":[[" ",""]],"content":" 错误原因是：mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password 我的mysql是8.0的用的caching_sha2_password加密方式，navicat版本不支持 解决办法：要么用新版本的navicat，要么把mysql的加密规则改成mysql_native_password cmd进入MySQL的bin目录 要正确拼写路径 输入mysql -u root -p，输入密码 设置加密方式为mysql_native_password并更改密码 密码自己设置一下，我一向为了好记就设为admin123了，哈哈 刷新 重新连接测试成功 "},{"title":"git初始化配置","date":"2020-02-13T08:50:54.000Z","url":"/2020/02/13/git%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/","tags":[["git","/tags/git/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":"今天登录了一下github，发现我的Contributions Graph上最近一次提交还是一月一号，而我最近一直在更新，竟然没有记录 发现是没有git初始化设定，假期回来我是用的笔记本更新，这台机器没有初始化，github是根据提交的邮箱来确认身份的，所以就没有记录下来 另外和上传的分支也有关系 查看配置信息 修改配置命令 输入git config ：来检查Git的某一项配置 最后测试了一下 问题解决"},{"title":"一元函数微分学的计算","date":"2020-02-13T08:11:17.000Z","url":"/2020/02/13/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E7%9A%84%E8%AE%A1%E7%AE%97/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"四则运算若以下函数均可导 扩展：[u(x)v(x)w(x)]′=u′(x)v(x)w(x)+u(x)v′(x)w(x)+u(x)v(x)w(x)′ 分段函数的导数分段点定义 非分段点公式 复合函数的导数与一阶微分方程的不变性复合函数链式求导 无论u是中间变量还是自变量，dy=f‘(u)du都成立 反函数的导数反函数的导数等于直接函数导数的倒数 如果函数x=f(y)可导，且f ′ (y) ≠0，则存在反函数x=φ(y)，且 注意 函数可导，且导数值 ≠0，那么导数保号不是正就是负 函数单调必有反函数 参数方程所确定的函数的导数设y=f(x)由参数方程 确定，其中t是参数，且φ(t)和ϕ(t)都可导，且φ′(t)≠0，则有 隐函数求导法隐函数定义 如果方程F(x,y)=0能确定y是x的函数，那么称这种方式表示的函数是隐函数 (关系隐含在方程中，但是无法表示成显函数的形式的函数) 求导方法 （1）方程F(x,y)=0两边对自变量x求导，将y看成中间变量，得到一个关于的y’方程 （2）求y’ 对数函数求导法求导方法 （1）先对函数y=f(x) 取对数 ln⁡y=lnf(x) （2）两边对x求导(将y看成中间变量)得 y′=f(x)f′(x) 这种方法主要应用于下列两种情况： 1，函数是幂指函数 2，函数混合了多重乘、除法及根式 幂指函数求导法先化成指数函数然后求导 化成指数函数 求导 高阶导数归纳法莱布尼兹公式泰勒公式变现积分求导公式基本求导公式"},{"title":"一元函数微分学的概念","date":"2020-02-11T08:22:47.000Z","url":"/2020/02/11/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E7%9A%84%E6%A6%82%E5%BF%B5/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"导数的概念定义 若函数y=f(x)在x0邻域内有定义，且x+∆x在邻域内，则增量∆y为 当 存在，则称f(x)在x0处可导 并称这个极限为f(x)在x0处的导数 注意： 增量有时候会广义化 可以把增量写成差的形式(两种形式) 等价提法 y=f(x)在x0处可导 y=f(x)在x0处导数存在 f’(x)=A(A为有限数)↔常数 单侧导数 导数充要条件 导数不存在的两种情况1.角点 y=f(x)=|x|在x=0的切线 证明 2.铅垂线 y=f(x)=x^1/3在x=0的切线 证明 光滑不一定可导 导数的几何意义函数y=f(x)在点x0的导数f’(x)就是y=f(x)在点(x0,y0)处的切线斜率 高阶导数 其中n≥2，x0+∆x在邻域内 微分的概念若函数y=f(x)在x0邻域内有定义，且x+∆x在邻域内，则增量∆y为 若存在一个与∆x无关的常数A，使得 则称f(x)在x0处可微 称A∆x为f(x)在x0处的微分 A∆x被称为线性主部，o(x)称为误差，记作 可微的判别 写增量 写线性增量 做极限 若极限等于0则f(x)在x=x0处可微，否则不可微 上面的步骤可以看出，用形式简单的量“线性增量A∆x”去代替形式复杂的量“增量∆y”，且其中误差“∆y-A∆x”是“o(∆x)”可以忽略不记，这就是微分的含义 可导必可微，可微必可导，互为充要条件 可微的几何意义"},{"title":"函数连续性","date":"2020-02-10T12:11:21.000Z","url":"/2020/02/10/%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E6%80%A7/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"连续与间断定义（逐点的概念） 设函数f(x)在点x0的某一邻域内有定义，当函数极限值等于函数值时，称函数在x0连续 极限是个过程，连续必须要有过程，点x0的某一邻域内有定义这是前提 可去间断点函数f(x)在点x0的某一邻域内有定义 （f(x0)甚至可以无定义） 则称这类间断点为可去间断点 可去即可补，把没定义的补上就连续或不等的改成等于就连续了 跳跃间断点函数f(x)在点x0的某一邻域内有定义 则称这类间断点为跳跃间断点 两个极限值存在，不相等 以上两点统称第一类间断点 无穷间断点函数f(x)在点x0的某一邻域内有定义 则称这类间断点为无穷间断点 (同济七版举了个例子)如函数y=1/x的点x=0处为无穷间断点 华罗庚先生说过程两边至少一个为无穷大也叫无穷间断点 振荡间断点函数f(x)在点x0的某一邻域内有定义 当x➡x0时，f(x)的极限振荡不存在 则称这类间断点为振荡间断点 (同济七版举了个例子)图像 x=0称为震荡间断点 以上两点属于第二类间断点 注意在x0的去心邻域内有定义才讨论间断点（有双侧定义才讨论间断点）"},{"title":"年轻人不怕吃苦，不怕熬夜","date":"2020-01-31T08:47:39.000Z","url":"/2020/01/31/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E4%B8%8D%E6%80%95%E5%90%83%E8%8B%A6%EF%BC%8C%E4%B8%8D%E6%80%95%E7%86%AC%E5%A4%9C/","tags":[["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":" your browser does not support the video tag 今天是2020年一月31号，这是一年前的视频，看起来依然十分感慨；年轻人不怕吃苦，不怕熬夜，加油 宇哥狮子王 狗减sin狗等于六分之一狗三 视频转自B站，怕以后找不到，所以插个眼"},{"title":"函数与极限考试题型","date":"2020-01-23T11:20:40.000Z","url":"/2020/01/23/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90%E8%80%83%E8%AF%95%E9%A2%98%E5%9E%8B/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"函数与极限考试题型1.无穷小比阶无穷小定义 如果函数f(x)当x→x0(或x→∞)时的极限为0，那么，f(x)称函数x→x0(或x→∞)时的无穷小 记作 无穷大定义与无穷小相对 如果函数f(x)当x→x0(或x→∞)时，|f(x)|无限增大，那么，f(x)称函数x→x0(或x→∞)时的无穷大 记作 无穷小比阶 不是任意两个无穷小都可以进行比阶，当比值不存在就不能比阶 无穷小比阶和洛必达法则类似：如果结果不存在洛必达失效 2.七种未定式 x→·第一类 常规类 设置分母原则：简单因式下放 简单：幂函数，指数数函数 复杂：初等函数 第二类 减法类 有分母则通分，没有分母创造分母 第三类 幂指类 1.化简 提出极限不为0的项目 等价无穷小替换 恒等变形 公因式，拆项，合并，分子分母同除最高次幂，换元法 对于0·∞型，可以选择下放其中一个因式，转化为另外两种形式处理。 碰到两个分式的减法，首先想到的就是通分，转化为上面的常规类未定式， 如果看到的是两个整式相除，通常可以使用提取公因式或者是倒代换，转化成分式相减的形式。 解题经验：**分子简单，分母难不好求解 正三角** 分母简单，分子难不好求解 倒三角"},{"title":"函数极限","date":"2020-01-18T06:45:46.000Z","url":"/2020/01/18/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"主要是计算 邻域(1)一维情况 以x为中心的任何开区间称为x的邻域，记作U（x） (2)二维情况 设P0(x0,y0)是XOY平面上的一点，δ是一个正数，与P(x0,y0)距离小于δ的点P(x,y)的全体称为点P的δ邻域，记为U(P0,δ) 极限定义设函数f(x)在点x0的某一去心邻域内有定义，如果存在常数A，对于任意给定的正数ε（无论它多么小），总存在正数δ，使得当x满足不等式0&lt;|x-x0|&lt;δ时，对应的函数值f(x)都满足不等式： |f(x)-A|&lt;ε那么常数A就叫做函数f(x)的极限，记作 或 ε-δ语言 ε-X语言 函数极限存在充要条件 等式脱帽法 性质唯一性 如果函数极限存在，那么极限唯一 指数函数，反三角函数，带绝对值的函数，取整函数要分零正零负讨论 局部有界性 如果函数极限存在，则存在正常数M和δ，当0&lt;|x-x0|&lt;δ,有|f(x)|≤M 函数存在极限必有界，有界不一定有极限y=sinx 导函数在有限区间有界,则函数在该区间上有界 闭区间上连续，必有界 有界函数与有界函数和差化积还是有界函数（有限次） 局部保号性 如果函数极限A&gt;0,再去心邻域上，函数&gt;0 如果f(x)≥0且极限为A(x→x0),则A≥0 五种方法求七种未定式运算规则若f(x),g(x)极限存在，则它们四则运算的结果就是极限的对应计算（注意除法被除数不为0） 注意：lim[ f(x) ]^n=[ limf(x) ]^n (n为正整数) 夹逼准则若lim g（x）=A，lim h（x）=A 且g(x)≤f(x)≤h(x) 则f(x)存在极限且极限为A 设任意的x总有φ(x)≤f(x)≤g(x),且lim[g(x)-φ(x)]=0，只能说明两个函数的差的极限存在，不能证明φ(x),g(x)极限相等，有可能是无穷大不存在 洛必达法则洛必达法则是用来简化极限运算的 那么 洛必达条件是“0/0”或“∞/∞”，两函数可导且被除的导函数不为0，导数除法的极限存在 洛必达可能失效：右存在，左必存在；左存在，右不一定存在 泰勒公式用多项式函数去逼近光滑函数 如果函数 f(x)在含 x0的某个开区间 (a,b)内具有直到 (n+1) 阶导数，则对∀x∈(a,b) ，有 麦克劳林公式是泰勒公式的一种特殊情况：即当 x0=0时的泰勒公式。所以将x0=0 带入公式，得 常用公式 等价无穷小代换式 高阶无穷小计算规则 有限个无穷小是无穷小 有界乘与无穷小是无穷小 有限个无穷小是无穷小 无穷小运算 设m，n是两个正数 加减法时低阶吸收高阶 乘法时阶数累加 非零常数相乘不影响阶数 泰勒公式展开规则 1.A/B型，上下同阶 分子分母都化成相同的x的k次幂 2.A-B型，幂次最低 A，B都化到它们系数不相等的x的最低最低次幂为止 海涅定理（归结原则）将函数极限与数列极限联系起来（从离散到连续） 正推一般是计算，计算出函数极限就是对应数列的极限，数列的变量是离散量，不能用洛必达法则，也不能用求导工具，所以用函数就更好算 倒推一般是证明，任意个用穷举法永远取不完，证明很难，但是找到两个数列极限不同就能证明函数极限不存在"},{"title":"数列极限","date":"2020-01-17T09:13:29.000Z","url":"/2020/01/17/%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"数列极限定义设一个数列{an}，存在一个常数a，使得任意一个正数ε（不管他有多小），总存在一个N，当n&gt;N时 |an-a|&lt;ε 恒成立，则称数a是数列 {an} 的极限，或称数列 {an} 收敛于 ε 若不存在这样的数a，则称数列 {an} 是发散的 ε-N语言 ∀ 是Arbitrary(任意的)上下倒写，∃是Exist(存在)左右倒写 数列收敛与子数列收敛的关系子列 从数列{an}中按规则选取n项，按原先数列的顺序组成的新数列，称新数列为原数列的子列，记为 例如nk(k=1,2⋯)取{an}对应2k的子列 定理 若是数列{an}收敛，则其子列必然收敛 推论 如果原数列收敛于a，则它的子列也是收敛于a 判断数列发散： 原数列的子列是发散的，则原数列必然发散 原数列的两个子数列收敛于不同的极限，则原数列必然发散 收敛数列的性质定理1唯一性 若数列存在极限a，则a唯一 定理2有界性 若数列极限存在，则数列有界 若数列{Xn}满足：对一切n 有Xn≤M 其中M是与n无关的常数 称数列{Xn}上有界（有上界）并称M是他的一个上界对一切n 有Xn≥m 其中m是与n无关的常数 称数列{Xn}下有界（有下界）并称m是他的一个下界一个数列{Xn}，若既有上界又有下界，则称之为有界数列。显然数列{Xn}有界的一个等价定义是：存在正实数X，使得数列的所有项都满足|Xn|≤X(n=1,2,3，……) 定理3保号性：在局部范围内保持恒正或恒负的性质 若数列存在极限a，且a&gt;0(或a&lt;0),则存在正整数N，当n&gt;N时，an&gt;0(或an&lt;0) 推论 如果数列从某项起an≥0，且数列存在极限a，则a≥0 极限运算规则若 则 运算规则可以推广至有限个数列 夹逼准则如果数列{xn}{yn}{zn}满足下列条件 则数列{xn}存在极限，且极限为a 单调有界准则单调有界数列必有极限，即若数列{xn}单调增加(减少)且有上界(下界)，则极限存在"},{"title":"高数基本知识","date":"2020-01-13T05:17:16.000Z","url":"/2020/01/13/%E9%AB%98%E6%95%B0%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"知识点全为摘录 数列等差数列 等差数列通项公式an=a1+(n-1)d 前n项和Sn=n(a1+an)/2 等比数列 等比数列通项公式an=a1*q^(n-1) 前n项和 Sn=na1 q=1 Sn=a1(1-q^n)/(1-q) (q≠1) 常见数列和 1+2+3+4+···n=n(n+1)/2 1^2+2^2+3^2+···n^2=n(n+1)(2n+1)/6 1/(1x2)+1/(2x3)+1/(3x4)+···1/n(n+1)=n/(n+1) 三角函数奇变偶不变，符号看象限诱导公式sin(-a) = -sin(a)cos(-a) = cos(a)sin(π/2-a) = cos(a)cos(π/2-a) = sin(a)sin(π/2+a) = cos(a)cos(π/2+a) = -sin(a)sin(π-a) = sin(a)cos(π-a) = -cos(a)sin(π+a) = -sin(a)cos(π+a) = -cos(a)tgA=tanA = sinA/cosA两角和公式sin(A+B) = sinAcosB+cosAsinBsin(A-B) = sinAcosB-cosAsinBcos(A+B) = cosAcosB-sinAsinBcos(A-B) = cosAcosB+sinAsinBtan(A+B) = (tanA+tanB)/(1-tanAtanB)tan(A-B) = (tanA-tanB)/(1+tanAtanB)cot(A+B) = (cotAcotB-1)/(cotB+cotA)cot(A-B) = (cotAcotB+1)/(cotB-cotA)倍角公式tan2A = 2tanA/(1-tan² A)Sin2A=2SinA•CosACos2A = Cos^2 A–Sin² A=2Cos² A—1=1—2sin^2 A三倍角公式sin3A = 3sinA-4(sinA)³;cos3A = 4(cosA)³ -3cosAtan3a = tan a • tan(π/3+a)• tan(π/3-a)半角公式sin(A/2) = √{(1–cosA)/2}cos(A/2) = √{(1+cosA)/2}tan(A/2) = √{(1–cosA)/(1+cosA)}cot(A/2) = √{(1+cosA)/(1-cosA)} ?tan(A/2) = (1–cosA)/sinA=sinA/(1+cosA)和差化积sin(a)+sin(b) = 2sin[(a+b)/2]cos[(a-b)/2]sin(a)-sin(b) = 2cos[(a+b)/2]sin[(a-b)/2]cos(a)+cos(b) = 2cos[(a+b)/2]cos[(a-b)/2]cos(a)-cos(b) = -2sin[(a+b)/2]sin[(a-b)/2]tanA+tanB=sin(A+B)/cosAcosB积化和差sin(a)sin(b) = -1/2*[cos(a+b)-cos(a-b)]cos(a)cos(b) = 1/2*[cos(a+b)+cos(a-b)]sin(a)cos(b) = 1/2*[sin(a+b)+sin(a-b)]cos(a)sin(b) = 1/2*[sin(a+b)-sin(a-b)]万能公式sin(a) = [2tan(a/2)] / {1+[tan(a/2)]²}cos(a) = {1-[tan(a/2)]^2} / {1+[tan(a/2)]²}tan(a) = [2tan(a/2)]/{1-[tan(a/2)]^2}其它公式a•sin(a)+b•cos(a) = [√(a²+b²)]*sin(a+c) [其中，tan(c)=b/a]a•sin(a)-b•cos(a) = [√(a²+b²)]*cos(a-c) [其中，tan(c)=a/b]1+sin(a) = [sin(a/2)+cos(a/2)]²;1-sin(a) = [sin(a/2)-cos(a/2)]²;其他非重点三角函数csc(a) = 1/sin(a)sec(a) = 1/cos(a)双曲函数sinh(a) = [e^a-e^(-a)]/2cosh(a) = [e^a+e^(-a)]/2tg h(a) = sin h(a)/cos h(a)公式一：设α为任意角，终边相同的角的同一三角函数的值相等：sin（2kπ＋α）= sinαcos（2kπ＋α）= cosαtan（2kπ＋α）= tanαcot（2kπ＋α）= cotα公式二：设α为任意角，π+α的三角函数值与α的三角函数值之间的关系：sin（π＋α）= -sinαcos（π＋α）= -cosαtan（π＋α）= tanαcot（π＋α）= cotα公式三：任意角α与 -α的三角函数值之间的关系：sin（-α）= -sinαcos（-α）= cosαtan（-α）= -tanαcot（-α）= -cotα公式四：利用公式二和公式三可以得到π-α与α的三角函数值之间的关系：sin（π-α）= sinαcos（π-α）= -cosαtan（π-α）= -tanαcot（π-α）= -cotα公式五：利用公式-和公式三可以得到2π-α与α的三角函数值之间的关系：sin（2π-α）= -sinαcos（2π-α）= cosαtan（2π-α）= -tanαcot（2π-α）= -cotα公式六：π/2±α及3π/2±α与α的三角函数值之间的关系：sin（π/2+α）= cosαcos（π/2+α）= -sinαtan（π/2+α）= -cotαcot（π/2+α）= -tanαsin（π/2-α）= cosαcos（π/2-α）= sinαtan（π/2-α）= cotαcot（π/2-α）= tanαsin（3π/2+α）= -cosαcos（3π/2+α）= sinαtan（3π/2+α）= -cotαcot（3π/2+α）= -tanαsin（3π/2-α）= -cosαcos（3π/2-α）= -sinαtan（3π/2-α）= cotαcot（3π/2-α）= tanα 指数运算法则 对数运算法则 一元二次方程基础一元二次方程一般形式 根的公式： 韦达定理 x1+x2=-b/a x1x2=c/a 判别式 抛物线y=ax^2+bx+c顶点(-b/2a,c-b^2/4a) 因式分解平方和 平方差 立方和 立方差 常用不等式Hn&lt;=Gn&lt;=An&lt;=QnHn&lt;=Gn&lt;=An&lt;=Qn调和平均数：Hn=n∑ni=11xiHn=n∑i=1n1xi几何平均数：Gn=∏ni=1xi−−−−−−√nGn=∏i=1nxin算术平均数：An=∑ni=1xinAn=∑i=1nxin平方平均数：Qn=∑ni=1x2in−−−−−−√Qn=∑i=1nxi2n绝对值不等式|a|−|b|&lt;=|a±b|&lt;=|a|+|b||a|−|b|&lt;=|a±b|&lt;=|a|+|b|琴生不等式凸函数：设 f(x)f(x) 在区间 I 上有定义，如果对任意 x1,x2∈Ix1,x2∈I 和实数 λ∈(0,1)λ∈(0,1) 总有f(λx1+(1−λ)x2)&lt;=λf(x1)+(1−λ)f(x2)f(λx1+(1−λ)x2)&lt;=λf(x1)+(1−λ)f(x2)成立，则称 f(x)f(x) 在区间 I 上为下凸函数变形：f(x1)f(x2)⋯f(xn)&gt;=f(x1+x2+⋯+xnn)f(x1)f(x2)⋯f(xn)&gt;=f(x1+x2+⋯+xnn)琴生不等式：若 f 为 [a,b] 上的凸函数，则对任意 xi∈[a,b],λi&gt;0,∑ni=1λi=1xi∈[a,b],λi&gt;0,∑i=1nλi=1,有f(∑i=1nλixi)&lt;=∑i=1nλif(xi)f(∑i=1nλixi)&lt;=∑i=1nλif(xi)伯努利不等式对实数 x&gt;−1x&gt;−1当 n&gt;=1n&gt;=1,有 (1+x)n&gt;=1+nx(1+x)n&gt;=1+nx当 0&lt;=n&lt;=10&lt;=n&lt;=1，有 (1+x)n&lt;=1+nx(1+x)n&lt;=1+nx当且仅当 n=0,1n=0,1 或 x=0x=0 时等号成立一般式：(1+x1+x2+x3+⋯+xn)&lt;=(1+x1)(1+x2)(1+x3)⋯(1+xn)(1+x1+x2+x3+⋯+xn)&lt;=(1+x1)(1+x2)(1+x3)⋯(1+xn)柯西不等式∑i=1na2i∑i=1nb2i&gt;=(∑i=1naibi)2∑i=1nai2∑i=1nbi2&gt;=(∑i=1naibi)2 即 |a→||b→|&gt;=|a→ ˙b→||a→||b→|&gt;=|a→ ˙b→|排序不等式若数列 {an}、{bn}{an}、{bn} 满足单调不下降，则有：顺序和 &gt;= 乱序和 &gt;= 逆序和 切比雪夫不等式若有 a1&gt;=a2&gt;=⋯&gt;=an,b1&gt;=b2&gt;=⋯&gt;=bna1&gt;=a2&gt;=⋯&gt;=an,b1&gt;=b2&gt;=⋯&gt;=bnn∑i=1n(aibi)&gt;=(∑i=1nai)(∑i=1nbi)&gt;=n∑i=1n(aibn−i+1)n∑i=1n(aibi)&gt;=(∑i=1nai)(∑i=1nbi)&gt;=n∑i=1n(aibn−i+1)放缩1n2&lt;1n2−14=2(12n−1−12n+1)1n2&lt;1n2−14=2(12n−1−12n+1)1n2&lt;1n(n−1)=1n−1−1n1n2&lt;1n(n−1)=1n−1−1nlnx&lt;=x−1→lnxx&lt;=1−1xln⁡x&lt;=x−1→ln⁡xx&lt;=1−1x1k√&gt;2k√+k+1√＝2(k+1−−−−√−k−−√)1k&gt;2k+k+1＝2(k+1−k)1n+2√&lt;n+2−−−−√−n−−√1n+2&lt;n+2−n2(n+1−−−−√−n−−√)&lt;1n√&lt;2(n−−√−n−1−−−−√)2(n+1−n)&lt;1n&lt;2(n−n−1)ex1. a&gt;1，n∈Nn∈N，n&gt;1，求证 a−−√n−1&lt;a−1nan−1&lt;a−1n令 x=a−−√n−1x=an−1，则 (x+1)n=a(x+1)n=a即证 nx&lt;(x+1)n−1nx&lt;(x+1)n−1(x+1)n−1=C0nxn+⋯+Cn−1nx+1−1&gt;Cn−1nx=nx(x+1)n−1=Cn0xn+⋯+Cnn−1x+1−1&gt;Cnn−1x=nxex2. 求证 ln223+ln333+⋯+lnnn3&lt;1eln⁡223+ln⁡333+⋯+ln⁡nn3&lt;1e(lnxx)′=1−lnxx2(ln⁡xx)′=1−ln⁡xx2∴x=e，(lnxx)max=1e∴x=e，(ln⁡xx)max=1e∑ni=2lnii3&lt;∑ni=21ei2&lt;1e∑ni=21(i−1)i&lt;1e∑i=2nln⁡ii3&lt;∑i=2n1ei2&lt;1e∑i=2n1(i−1)i&lt;1eex3.利用 (n−1)(n+1)&lt;=n2(n−1)(n+1)&lt;=n21⋅3⋅5⋯(2n−1)2⋅4⋅6⋅⋯⋅(2n)=12⋅32⋅52⋯(2n−1)2⋅(2n+1)22⋅42⋅62⋯(2n)2⋅(2n+1)−−−−−−−−−−−−−−−−√&lt;12n+1√1⋅3⋅5⋯(2n−1)2⋅4⋅6⋅⋯⋅(2n)=12⋅32⋅52⋯(2n−1)2⋅(2n+1)22⋅42⋅62⋯(2n)2⋅(2n+1)&lt;12n+1ex4. 证明 ∑nk=112k−1∑k=1n12k−1当 n&gt;=2n&gt;=2 时，(2n−1)−3⋅2n−2=2n−2−1(2n−1)−3⋅2n−2=2n−2−1于是 12n−1&lt;=13⋅12n−212n−1&lt;=13⋅12n−2∑nk=112k−1&lt;1+13∑n−2k=02−k&lt;53∑k=1n12k−1&lt;1+13∑k=0n−22−k&lt;53"},{"title":"函数的图像","date":"2020-01-11T10:09:45.000Z","url":"/2020/01/11/%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%BE%E5%83%8F/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":" 直角坐标系下的图像基本初等函数：常反对幂指三 常函数 y=c,一条平行于x轴的直线 x=c,一条平行于y轴的直线 幂函数 三个代表+奇偶性 ​ 1&lt;u u=2 偶函数 ​ 0&lt;u&lt;1 u=1/2 偶函数 ​ u&lt;0 u=-1 奇函数 指数函数 图像过（0，1）这个点 1&lt;a,增函数 0&lt;a&lt;1,减函数 对数函数 图像过（1，0）这个点 1&lt;a,增函数 0&lt;a&lt;1,减函数 y=lnx和y=ex互为反函数 三角函数 y=sinx y=cosx y=tanx y=csex y=secx y=cotx 反三角函数 分段函数 图像变换：平移，对称，伸缩 极坐标系的图像描点法常见图像 心形线 玫瑰线 阿基米德螺线 伯努利双扭线 参数法—参数方程 摆线 星形线 "},{"title":"函数概念与特性","date":"2020-01-11T01:29:08.000Z","url":"/2020/01/11/%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%89%B9%E6%80%A7/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"],["考研","/tags/%E8%80%83%E7%A0%94/"]],"categories":[[" ",""]],"content":"函数 your browser does not support the video tag 假设有两个变量x、y，如果对于任意一个x都有唯一确定的一个y和它对应，那么就称y是x的函数。x的取值范围叫做这个函数的定义域，相应y的取值范围叫做函数的值域 反函数设函数y=f(x)的定义域是D，值域是f(D)。如果对于值域f(D)中的每一个y，在D中有且只有一个x使得g(y)=x，则按此对应法则得到了一个定义在f(D)上的函数，并把该函数称为函数y=f(x)的反函数 严格单调函数一定有反函数，有反函数不一定严格单调 y=f(x)与x=f-1(y)的图像相同,图形关于y=x对称的原因是因为y与x互换的结果 复合函数 复合函数 f (x)+ g (x) 的单调性 增函数 f (x) + 增函数 g(x) 是增函数 减函数 f (x) + 减函数 g(x) 是减函数 增函数 f (x) - 减函数 g(x) 是增函数. 4.减函数 f (x) - 增函数 g(x) 是减函数 复合函数 f [g(x)] 的单调性 若 f(x) 与 g(x) 的单调性相同，则 f [g(x)] 为增函数 若 f(x) 与 g(x) 的单调性相反，则 f [g(x)] 为减函数. 四种特性：有界性设f(x)的定义域为D，数集 I⊂D，如果存在某个正数M，对于任一x∈I，有 |f(x)|≤M，则称f(x)在I上有界；如果不存在这样的M，则称f(x)在I上无界 几何上，找得到上下界把图像包起来，称有界；解析上，找得到一个正数M，|f(x)|≤M，称有界 有界还是无界首先指明区间I，不知区间，无法谈论有界性 只要在区间I上存在一点x0，使得值为无穷大，就可以证明在区间I上无界 单调性f(x)定义域 D 上任意两个值x1,x2 ,有x1&lt;x2 ;若f(x1)&lt;f(x2) ,函数在D上**单调增加**;若 f(x1)&gt;f(x2),函数在D上单调减少注意单调性定义的不同表示方法 奇偶性在定义域内的任意一个x,f(-x)=-f(x),则f(x)是奇函数；函数图像关于原点对称；若x=0有意义，f（0）=0在定义域内的任意一个x,f(-x)=f(x),则f(x)是偶函数；函数图像关于y轴对称；若x=0有意义，f‘（0）=0在定义域内的任意一个x,f(-x)=-f(x)且f(-x)=f(x)同时成立,则f(x)是既奇又偶函数在定义域内的任意一个x,f(-x)=-f(x)与f(-x)=f(x)都不成立,则f(x)是非奇非偶函数设f(x)定义在（l，-l）上的任意函数 F(x)=f(x)-f(-x)必为奇函数，F(x)=f(x)+f(-x)必为偶函数y y=f(x)与y=-f(x)关于x对称;y=f(x)与y=f(-x)关于y对称;y=f(x)与y=-f(-x)关于原点对称 y=f(x)关于x=T对称充要条件f(x)=f(2T-x)或f(T-x)=f(T+x) 周期性设函数f(x)的定义域为D。如果存在一个正数T，使得对于任一x∈D有(x士T)∈D，且f(x+T)=f(x)恒成立，则称f(x)为周期函数，T称为f(x)的周期，通常我们说周期函数的周期是指最小正周期。周期函数的定义域D为至少一边的无界区间，若D为有界的，则该函数不具周期性 重要结论 若f(x)是可导偶函数，则f’(x)奇函数 若f(x)是可导奇函数，则f’(x)偶函数 若f(x)是可导周期函数，则f’(x)也是以T为周期的周期函数 连续的奇函数的一切原函数都是偶函数 连续的偶函数的原函数只有一个是奇函数 连续的函数以T为周期，且，则f(x)的一切原函数也以T为周期 f(x)在(a,b)区间内可导且f’(x)有界，则f(x)在(a,b)有界 "},{"title":"计算机网络概述","date":"2020-01-09T13:27:45.000Z","url":"/2020/01/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/","tags":[["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[[" ",""]],"content":"最早的计算机网络是美国军方的Arpanet，后来网络从军方转为民用，形成了今天的互联网；通过互联网，我们可以很方便的发布信息，获取信息，完成信息的交互 那网络是怎么实现的呢 原本由于时间或空间的限制，信息是分散的；那么把计算机作为传送信息的起点，网络将一些计算机相连，而互联网则将这些网络相连；原本分散的信息就连接在了一起；当我们从任一联网的计算机访问时，都能通过网络访问网络上的全部节点 计算机网络组成 资源连接网络的目的就是为了信息的交互，所以得有资源 设备（硬件和通讯系统）要完成信息交互得有硬件基础和软件（通信系统），这里的硬件不仅仅只有计算机，还有独立的硬件 协议有了硬件和软件，只是有了通讯的能力，他们之间仍然不能通讯；原因这些设备千差万别，你不可能让所有联网的设备都相同；人们制定了通讯协议，允许设备内部实现差异，但在通讯时，就必须遵守通讯协议（学术上的osi七层模型和实际上的工业标准TCP/IP（Transmission control protocol/Internet protocol)） 互联 1. 计算机网络硬件：计算机（PC,server,小型，中型，大型，巨型机，网络通信设备（hub集线器，switch ,router路由器，firewall防火墙，加密机，传输介质：有线：双绞线（非屏蔽超五类），光纤（多模光纤），同轴电缆)，无线（红外线，微波等电磁波），网络软件（网络系统软件：OS(win 2008 server,win 7,协议，网络应用软件：微信，QQ，迅雷）客户机，服务器 2.计算机网络的定义功能数据通信，资源共享：硬件，软件，数据资源等 分类 按拓扑结构划分：总线型，星型，树型，网状，环型，混合型等 按覆盖范围划分：LAN,MAN,WAN），计算机网络的性能指标(速率，带宽，吞吐量，时延) 3.网络协议通信双方共同遵守的规则和约定的集合，普通话 三要素语法，语义，时序 osi每层对应的网络通信设备网线，集线器－－－－物理层 网卡，网桥－－－－数据链路 路由器－－－－－网络层 osi与TCP/IP四层模型的对应关系"},{"title":"Cache原理","date":"2020-01-01T05:28:05.000Z","url":"/2020/01/01/Cache%E5%8E%9F%E7%90%86/","tags":[["计算机组成原理","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"],["cache","/tags/cache/"]],"categories":[[" ",""]],"content":"Cache原理由于cpu与主存（DRAM）速度有差异，为了提高访存速度，产生了cache（高速缓冲寄存器)； Cache（SRAM)利用了程序访问的局部性原理，即时间局部性和空间局部性 当前正在使用的指令或数据，在不久的将来，还会使用 当前正在使用的指令或数据相邻的指令或数据，在不久的将来，还会使用 cache和主存交换数据的单位是块，这个块包含了正在使用的指令或数据（时间），也包含了相邻的指令或数据（空间） cache的基本结构 cache命中相关的两个机制 主存-Cache地址映射变换 cache替换机制 cache命中率cache速度比主存快，所以我们更希望是从cache中取数据，所以cache命中率越大越好； 设cache命中率h，Nc表示cache的存取次数，Nm表示主存的存取次数 cache-主存系统效率设cache访问时间tc,主存访问时间tm，当它们并行访问时， Ta = h⋅Tc+(1−h)⋅Tm 则效率eh 可以看到这个效率在 tc/tm ~ 1 如果先访问cache，在cache没有命中时再访问主存，Ta = h⋅Tc+(1−h)⋅(Tm+Tc) 则效率e 这是的效率在 tc/(tm+tc) ~ 1 对比下：并行访问的最低效率是高于串行访问的 cache读操作 读操作不对主存-cache信息进行修改 cache写操作写操作会修改信息，有两种方法： 写直达法：写操作既写入主存，又写入cache；时刻保持了数据一致 写回法：写操作只写入cache，只有cache数据被擦除，才写回主存 写直达法可能会导致频繁的主存cache数据交换 写回法在多核cpu中，每个核都有cache，主存的块如果在不同cache都有备份就会有数据不一致问题"},{"title":"Cache替换算法","date":"2019-12-31T17:18:01.000Z","url":"/2020/01/01/Cache%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95/","tags":[["计算机组成原理","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"],["cache","/tags/cache/"]],"categories":[[" ",""]],"content":"Cache替换算法当我们准备把主存的数据拿到cache中时，如果cache已经满了，需要替换算法选择替换掉那块cache数据 近期最少使用（Least Recently Used）算法：替换最长时间没有被使用的页面 ，看时间 最不经常使用（Lease Frequently Used）算法： 替换使用频率最少的页面。 ，看频率 先入先出(First In First Out)算法：若当前Cache被填满，则替换最早进入Cache的那个 随机法：从特定位置随机取一行换出 "},{"title":"Cache映射","date":"2019-12-30T14:23:44.000Z","url":"/2019/12/30/cache%E6%98%A0%E5%B0%84/","tags":[["计算机组成原理","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"],["cache","/tags/cache/"]],"categories":[[" ",""]],"content":"Cache映射方式Cache的数据块叫行，主存的数据块叫块，他们是等长的 直接映射(directmapping):将一个主存块存储到唯一的cache行 全相联映射(fullyassociative mapping):可以将一个主存块存储到任意一个cache行 组相联映射(setassociative mapping):可以将一个主存块存储到唯一的一个cache组中任意一行 1.直接映射 多对一的映射关系，一个主存块只能拷贝到cache的一个特定行上去。 cache的行号i和主存的块号j有如下函数关系：i=j mod 2^c 优点：硬件简单，容易实现 缺点：命中率低， cache的存储空间利用率低 用c位字块地址找到cache对应的行，在比较器中，将主存字块号与此行的标记做比较。若命中，读取字块内地址对应的内容 2.全相联映射 主存的一个块直接拷贝到cache中的任意一块上 优点：命中率较高，cache的存储空间利用率高 缺点：线路复杂，成本高，速度低 在全相联映射方式中，在比较器中比较主存字块标记和cache行标记。若块号命中，读取字块内地址对应的内容 3.组相联映射 组相联映射和全相联映射的折中 将cache分成u组，每组v行，主存块存放到哪个组是固定的，至于存到该组哪一行是灵活的，即有如下函数关系：组号:q＝j mod u 组间采用直接映射，组内为全相联 硬件较简单，速度较快，命中率较高 用q位组地址找到cache的相应组，然后将主存字块标记和cache组内所有标记进行比较，如果找到了就命中"},{"title":"指针示例","date":"2019-12-30T09:37:27.000Z","url":"/2019/12/30/%E6%8C%87%E9%92%88%E7%A4%BA%E4%BE%8B/","tags":[["c","/tags/c/"],["指针","/tags/%E6%8C%87%E9%92%88/"],["汇编","/tags/%E6%B1%87%E7%BC%96/"]],"categories":[[" ",""]],"content":"指针示例学习了计算机组成原理之后，对指针有了新的认识 首先是计算机存储结构 当程序运行时，我们关注寄存器和主存 写一段指针的代码 反汇编 我的汇编代码格式是Intel的，dword ptr [p]表示一个内存的位置 在指令中，如果指明了某个专用寄存器，也就指明了要处理的数据的尺寸 在没有寄存器名存在的情况下，用操作符 X ptr 指明内存单元的长度，X可以是word或byte ; 有些指令默认了访问的是字单元还是字节单元，比如：push [1000H] 就不用指明访问的是字单元还是字节单元，因为push指令只进行字操作。 Intel的字（word）表示16位数据；一字节八位；b,w,l,q对应1,2,4,8字节 所以让指针p指向y实际是三条指令 把立即数0传到内存y中，给y赋值 int y = 0; 取内存y的有效地址，传到寄存器eax中 &y; 把寄存器eax的值，传到内存y中 赋值 c和指针中说，等号左边是地址，右边是一个值，指针存放的是指向的地址在汇编中，就有了更直观的体现比如c语言的值传递和地址传递 反汇编 对比下两边的操作 swap0（值传递） swap1(地址传递) mov eax,dword ptr [x1] lea eax,[y1] 拷贝了一份值传到寄存器eax 取了y1的地址到eax swap0 swap1 两边的函数确实都交换了，不同 swap0 swap1 交换拷贝的值 按地址寻址，交换的实际是内存中的值 "},{"title":"vs笔记","date":"2019-12-29T13:44:27.000Z","url":"/2019/12/29/vs%E7%AC%94%E8%AE%B0/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":"vs笔记常用快捷键： 快捷键 用途 Ctrl+K,Ctrl+F 快速格式化 Ctrl+K,C 注释选定内容 （Comment） Ctrl+K,U 取消选定注释内容 （UnComment） Ctrl+J /Ctrl+K,L 列出成员（kernel核心内容 list列表) 微软账号登不上去打开 帮助-&gt;发送反馈-&gt;报告问题 通过开发者社区登录解决了问题 "},{"title":"RSA非对称加密算法","date":"2019-12-28T11:40:23.000Z","url":"/2019/12/28/RSA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["网络安全","/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[[" ",""]],"content":"算法步骤: 随机选择两个不相同的素数 计算 计算n的欧拉函数 选择一个,使与互质,且（公约数只有1的两个自然数称互质数） 计算 对于 的模反元素 ,即找到一个 满足,就是求方程 的整数解(这个方程可以用扩展欧几里得算法求解) 最后公钥为 , 私钥为公钥 模反元素：模反元素：如果两个正整数e和r互质，那么一定能找到整数d，使得 ed%r=1 ，即 (ed-1)%r=0，则称d为e的模反元素 扩展欧几里得算法（辗转相除法）求二元一次方程整数解:用较大数除以较小数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数 内容 说明 公钥 私钥 加密 解密 实例这里找简单的例子熟悉一下算法流程： 1.选择p，q 假设 p=23,q=29 2.计算n n=23*29=667 3.计算欧拉函数 φ(n)=(23-1)*(29-1)=616 4.选一个e,(1&lt;e&lt;φ (n)) 假设e=13,13和616是互质的满足条件 5.计算e对于φ(n)的模反元素d ed–kφ(n)=1 带入值得 13d-616k=1 辗转相除法 616/13=13*47+5 5=616-13*47 1式 13/5=5*2+3 3=13-5*2 2式 5/3=3*1+2 2=5-3*1 3式 3/2=2*1+1 1=3-2*1 4式 我们求解最后都要化成1=13d-616k的形式，所以要消去多余的2，3，5 3代入4得5 2代入5得6 1代入6得到13d-616k的形式 得1=237x13-5x616 即d=237,k=-5 因为模反元素不止一个,d+kφ(n) 都是e的模反元素，这里k就取0 d=d+kφ(n)=237-0x616=237， 6.公钥(13,667),私钥(237,667) 下面加密解密验证一下 假设明文是55 c=m^e mod n=55^13mod667=242 解密 m=c^d mod n=242^237mod667=55 流程图 补充：大数模幂运算快速算法计算像9%2,4%2这种简单的很容易，也很好表示，但是像上面的242^237%667就不太好表示了，242^237的结果有多少位不知道，累乘是肯定会溢出的，而且效率不高，这里补充一个大数模幂运算快速算法假设有整数a, b与除数m ,那么假设a % m = j , b % m = t , 有整数 i , s , 使a=im+jb=sm+ta=im+jb=sm+t 所以有a⋅b=(im+j)⋅(sm+t)=ism2+jsm+itm+jta⋅b=(im+j)⋅(sm+t)=ism2+jsm+itm+jt 推出(a⋅b) mod m=(ism2+jsm+itm+jt) mod m=jt mod m=((a mod m)(b mod m))mod m(a⋅b) mod m=(ism2+jsm+itm+jt) mod m=jt mod m=((a mod m)(b mod m))mod m 因为abc mod m=((ab)⋅c) mod m=(((ab) mod m)(c mod m)) mod m=(((a mod m)(b mod m) mod m)(c mod m)) mod mabc mod m=((ab)⋅c) mod m=(((ab) mod m)(c mod m)) mod m=(((a mod m)(b mod m) mod m)(c mod m)) mod m 依次类推既可.我们再考虑大数幂m要如何分解成形如m=m1+m2+…+mnm=m1+m2+…+mn的形式.可以把大数幂m写成二进制,然后只取值为1的位,和这一位在二进制中从右到左的位数(从0开始计算),就可以得到这个大数幂的分解式了. RSA实现代码 结果 代码实现了简易的RSA算法，只能加密数值，不能满足真正的加密需求；实际上要想获得一定的安全性，公钥n的长度要达到1024位 RSA安全性算法安全性在于只知道密文和公钥，但是想要破解就要进行逆运算，最直接的是大整数的因数分解，但是对现在的计算水平或算法来说是一件非常困难的事。所以这里说的安全也只是相对的，基于现在的水平导致解决这个问题很困难，但是当随着计算水平的提高或者有了优秀的算法，RSA算法安全性就要打折扣了。道高一尺魔高一丈，加密技术和破解技术必是在相互磨练中前进。"},{"title":"汇编下的寻址方式","date":"2019-12-26T11:24:39.000Z","url":"/2019/12/26/%E6%B1%87%E7%BC%96%E4%B8%8B%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/","tags":[["计算机组成原理","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"categories":[[" ",""]],"content":"寻址方式要想了解寻址方式，首先得对计算机存储体系有一定了解 寄存器 cache 主存 辅存 网络 从上至下，存储速度由快变慢，存储容量由小变大 寄存器寻址模式 类型 格式 操作数值 名称 立即数 $Imm Imm 立即数寻址 寄存器 ra R[ra] 寄存器寻址 存储器 Imm M[Imm] 绝对寻址 存储器 (ra) M[R[ra]] 间接寻址 存储器 Imm(rb) M[Imm+R[rb]] (基址 + 偏移量)寻址 存储器 (rb,ri) M[R[ra]+R[ri]] 变址寻址 存储器 Imm(rb,ri) M[lmm+R[rb]+R[ri]] 变址寻址 存储器 (,ri,s) M[R[ri]*s] 比例变址寻址 存储器 Imm(,ri,s) M[Imm+R[ri]*s] 比例变址寻址 存储器 (rb,ri,s) M[R[rb]+R[ri]*s] 比例变址寻址 存储器 Imm(rb,ri,s) M[Imm+R[rb]+R[ri]*s] 比例变址寻址 指令的类型可以是立即数(i)，寄存器(R)，内存(M)。 立即数(immediate)，在汇编中直接以常数的形式存在。 寄存器(register)，存在某个寄存器的内容。 内存引用，他会根据计算出来的地址（通常称为有效地址）访问某个内存位置。 表中最后一种比例变址寻址是常见形式，比较适合引用数组和结构元素。这样的引用有四个部分组成：一个立即数Imm，一个基址寄存器rb ,一个变址寄存器ri和一个比例因子s，s必须是1、2、4或者8。 例子源码： 加上断点，进入调试。截取其中一段反汇编代码 我们可以看到 mov表示传送数据dword 双字 就是四个字节ptr pointer缩写 即指针[]里的数据是一个地址值，这个地址指向一个双字型数据5就是一个立即数，立即数引用而a在这里可以理解成一个地址(变量名a可以理解成你给这块空间地址取的别名)，就是直接引用 ebp是一个通用寄存器，一般保存被调用的数据 把4放到 [ebp-30h]就是变址寻址，Imm(rb,ri)的形式 我们知道，数组是一段连续的内存空间，这五条的偏移量的差是28h-24h，即为4；而一个int数据是4个字节，为什么这样就一目了然 mov ecx,dword ptr c[eax*4] c[3]=4,c做首地址，寄存器间接寻址，ECX作为间址寄存器"},{"title":"解析网页m3u8文件地址","date":"2019-12-24T07:32:51.000Z","url":"/2019/12/24/%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5m3u8%E6%96%87%E4%BB%B6%E5%9C%B0%E5%9D%80/","tags":[["java","/tags/java/"]],"categories":[[" ",""]],"content":"解析网页m3u8文件地址 getIndexFile类用来下载网页视频m3u8文件analysisIndex类用来解析m3u8文件，改写成url的形式openXunlei类是根据解析好的url地址打开迅雷下载前两个类没什么好说的，第三个类实现原理是把analysisIndex类生成的url存成文本，直接命名为.downlist文件。而.downlist是迅雷存下载地址的文件，存好后用runtime调cmd，直接打开这个文件，就能进下载页面了。所以，没有安装迅雷，第三不就不会执行，不过程序还是能生成一个解析好的url文件的。按需要改相应的参数。主类中urlPath是二级m3u8文件，注意，一级m3u8文件是不行的，因为一级里面是一些适配码率的代码，没有真正的视频地址文件。text.解析的url文件地址是m3u8文件解析好的url地址文件，按那个地址下就行了另外，上面代码也有一些问题，下载下来的视频全部都是.ts切片文件，下载后需要把他们合成一个整视频我一般用cmd合成copy /b 要合成的.ts文件路径*.ts 生成文件路径\\new.mp4*是通配符，具体参见百度还有一个问题，就是代码会在生成url的时候还会在控制台输出，而一旦输出过多，前面一部分就会丢失，所以不要用控制台生成的地址去下载靠谱的还是去生成文件里面去找，因为那样不会溢出。现在遇到的问题是有的视频很长切片太多，而我的迅雷一次最多添加1000个链接，我的想法是每生成1000个url后就重新生成一个文件，然后分开下载。还有一个待解决的问题，就是有些网站会对他的地址进行AES加密，表示暂时看见了没办法。"},{"title":"模拟浏览器爬取源码到本地","date":"2019-12-22T17:27:59.000Z","url":"/2019/12/23/%E6%A8%A1%E6%8B%9F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%88%AC%E5%8F%96%E6%BA%90%E7%A0%81%E5%88%B0%E6%9C%AC%E5%9C%B0/","tags":[["java","/tags/java/"],["爬虫","/tags/%E7%88%AC%E8%99%AB/"]],"categories":[[" ",""]],"content":"Spider类 Main 主类中的urlPath是要爬取网站的url htmlPath是本地存储地址 编写过程中出现的问题: 运行结果有乱码，spider虽然能正常下载网页代码，并能在txt中准确打开，但在浏览器中显示异常 结合输出，应该显示中文的地方都是？，推测是spider类输出流问题 原因是读取的格式和网页的编码不一致 spider 把utf-8改成目标网站编的码方式GBK就解决了问题 在爬网页的过程中，要先去网站看一下它的编码格式，要和它相同就不会乱码 具体可以参考博文： 补充一下有帮助的博文 用BufferedWriter 将内容写入文件： File类(5)-Reader和Writer、OutputStreamWriter 、BufferedWriter、字节流和字符流的区别 "},{"title":"四方定理","date":"2019-12-19T13:40:31.000Z","url":"/2019/12/19/%E5%9B%9B%E6%96%B9%E5%AE%9A%E7%90%86/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["蓝桥杯","/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"]],"categories":[[" ",""]],"content":"四方定理数论中有著名的四方定理：所有自然数至多只要用四个数的平方和就可以表示。我们可以通过计算机验证其在有限范围的正确性。 对于大数，简单的循环嵌套是不适宜的。下面的代码给出了一种分解方案。 四方定理可以改为：所有自然数都能用四个数的平方和表示；n=a^2+b^2+c^2+d^2（不足四个数的，其他的数就用零表示）拿到这题，先看主函数； for (;;)for循环里没有结束语句，表示程序一直循环，不从这里跳出； int number;printf(“输入整数(1~10亿)：”);scanf(“%d”, &amp;number);结合后面的printf语句，说明number表示有限范围所有自然数中的一个； int a[] = { 0,0,0,0 };然后他声明了一个数组a，里面的四个数都为0，可以猜测，这个数组是来存储a,b,c,d四个数的； int r = f(number, a, 0);最后它int了个r，调用了自定义函数f,并把f的返回值赋给r；在程序最后看r的值就能完成验证； if (__) return 1;if (idx == 4) return 0;整个函数return返回0或1；猜测这是两种状态，成功或失败； for (int i = (int)sqrt(n); i &gt;= 1; i–)(int)sqrt(n)强转了一下，把sqrt(n)转换成int；那四个数从i开始找起（i^2&lt;=n），一直找直到1； a[idx] = i;把i赋值给数组a； if (_______________________) return 1;返回1 整个函数f有四条return语句，相当于f有四个出口结束，因为f中return一旦执行，后面的代码就不会执行，所以f可以理解成四种不同的情况：1.if (填空1) return 1; 2.if (idx == 4) return 0; 3.for (int i = (int)sqrt(n); i &gt;= 1; i–) { a[idx] = i; if (填空2) return 1; } 4.for (int i = (int)sqrt(n); i &gt;= 1; i–) { a[idx] = i; } return 0; idx == 4的时候，说明不止四个数，所以0表示证明定理是假，1表示真；1和3都返回1，是能证明定理成立的；所有自然数从零开始，0的话是不能从3得到，所以只能从1得到；所以填空1这里填n==0；2和4都返回1，定理不成立；找到的多于四个的数（情况2）；还没找到四个数，就已经没有数找了（情况4）；填空2中应该用了递归，用n-i^2不断缩小n，idx就加一；填空二f(n-i*i,a,idx+1); 补充知识return的用法 1.背景介绍return表示从被调函数返回到主调函数继续执行，返回时可附带一个返回值，由return后面的参数指定。return通常是必要的，因为函数调用的时候计算结果通常是通过返回值带出的。如果函数执行不需要返回计算结果，也经常需要返回一个状态码来表示函数执行的顺利与否（-1和0就是最常用的状态码）， 主调函数可以通过返回值判断被调函数的执行情况。2.知识剖析返回值是必须有的，作用就是把固定不变的。常用的代码封装起来写在类里，每次用到的时候就调用就行了如果需要这个共能返回一个值，甚至一个对象 就需要用返回值了就是用return来把把值返回给调用的者return 语句会终止函数的执行并返回函数的值。比如：function a(){return 10;//这个时候，函数a的值会等于10，并且函数中下面的内容不再执行document.write(50);//由于上面已经return了，这条代码不会执行}至于什么时候会用到，那看你要函数来做什么，你要他返回值就返回咯，不要他返回就不返回咯！比如，用函数来做一个加法运算，需要他返回值：function a( b, c ){return b + c;}那么调用：var abc = a(5, 80);这个时候，abc这个变量的值会是85如果想直接输出结果，不要返回值那就function a( b, c ){document.write( b + c );}这个时候调用， var abc = a(5, 80);那么页面会输出85，但abc是没有值的;也可以说默认函数是没有返回值的。通常函数经过一系列处理后需要给外部返回一个值或者对象比如：function sum(a,b){return a+b};alert(sum(1,2))==&gt;3如果没有return将会弹出undefined3."},{"title":"迭代算法","date":"2019-12-03T11:59:45.000Z","url":"/2019/12/03/%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[[" ",""]],"content":"迭代算法中心思想是用旧值递推新值，一直迭代下来进而得到最终解。 典型的有兔子繁殖问题 一对兔子从出生后第三个月开始，每月生一对小兔子。小兔子到第三个月又开始生下一-代小兔子。假若兔子只生不死，一月份抱来一对刚出生的小兔子，向一年中每个月各有多少对兔子。 简单看，兔子数就是一个斐波那契数列1 1 2 3 5 8 13 21 34 55 89···从第三项开始，后一项等于前面两项之和 1+1=2 1+2=3 2+3=5 ··· 采用大数类是为了防止数值过大溢出，另外回忆一下Java的BigInteger写法，大数类原理就是把数值以数组的形式存下来，是一种空间换精度的策略。大数不能用加减符号运算，只能通过调sum()等方法运算"},{"title":"java查找特定文件","date":"2019-11-30T17:48:26.000Z","url":"/2019/12/01/java%E6%9F%A5%E6%89%BE%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6/","tags":[["java","/tags/java/"]],"categories":[[" ",""]],"content":"java查找特定文件"},{"title":"jdbc登陆查询","date":"2019-11-30T10:36:00.000Z","url":"/2019/11/30/jdbc%E7%99%BB%E9%99%86%E6%9F%A5%E8%AF%A2/","tags":[["java","/tags/java/"]],"categories":[[" ",""]],"content":"jdbc登陆查询我用的mysql 需要导入jar包：mysql-jar\\mysql-connector-java-5.1.47-bin.jar "},{"title":"javaio流","date":"2019-11-28T17:43:48.000Z","url":"/2019/11/29/javaio%E6%B5%81/","tags":[["java","/tags/java/"]],"categories":[[" ",""]],"content":"java i/o系统io流中的类十分繁复，存在的问题：不知道什么时候调什么类；下面正文 核心类 File InputStream OutputStream Reader Writer Closeable Flushable Serializable File类文件类：代表一个路径，可以表示一个文件，也可以表示文件夹(一组文件)，也可以创建一个文件(这个文件不存在)； 文件路径因为 “&quot; 具有特殊意义，所以文件路径写成字符串需要转义，改为\\;(这种写法有时没有可移植性，所以推荐下面两种写法) / 或者用File.separatorChar 连接 文件路径的三种写法： "},{"title":"提问的智慧","date":"2019-11-27T14:28:48.000Z","url":"/2019/11/27/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/","tags":[["转载","/tags/%E8%BD%AC%E8%BD%BD/"]],"categories":[[" ",""]],"content":"提问的智慧D.H.Grand[nOBODY/Ginux] 2001 在黑客世界里，当提出一个技术问题时，你能得到怎样的回答？这取决于挖出答案的难度，同样取决于你提问的方法。本指南旨在帮助你提高发问技巧，以获取你最想要的答案。 首先你必须明白，黑客们只偏爱艰巨的任务，或者能激发他们思维的好问题。 如若不然，我们还来干吗？如果你有值得我们反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼，可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，“问得好！”是发自内心的大力称赞。 尽管黑客们有蔑视简单问题和不友善的坏名声，有时看起来似乎我们对新手，对知识贫乏者怀有敌意，但其实不是那样的。 我们不想掩饰对这样一些人的蔑视–他们不愿思考，或者在发问前不去完成他们应该做的事。这种人只会谋杀时间–他们只愿索取，从不付出，无端消耗我们的时间，而我们本可以把时间用在更有趣的问题或者更值得回答的人身上。 我们称这样的人为“失败者”（由于历史原因，我们有时把它拼作“lusers”）。 我们在很大程度上属于志愿者，从繁忙的生活中抽出时间来解惑答疑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是抛弃那些看起来象失败者的家伙，以便更高效的利用时间来回答胜利者的问题。 如果你觉得我们过于傲慢的态度让你不爽，让你委屈，不妨设身处地想想。我们并没有要求你向我们屈服–事实上，我们中的大多数人最喜欢公平交易不过了，只要你付出小小努力来满足最起码的要求，我们就会欢迎你加入到我们的文化中来。但让我们帮助那些不愿意帮助自己的人是没有 意义的。如果你不能接受这种“歧视”，我们建议你花点钱找家商业公司签个技术支持协议得了，别向黑客乞求帮助。 如果你决定向我们求助，当然不希望被视为失败者，更不愿成为失败者中的一员。立刻得到有效答案的最好方法，就是象胜利者那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。 （欢迎对本指南提出改进意见。任何建议请E-mail至esr@thyrsus.com，然而 请注意，本文并非网络礼节的通用指南，我通常会拒绝无助于在技术论坛得到有用答案的建议。） （当然，如果你写中文，最好还是寄DHGrand@hotmail.com;-） **= 提问之前 =** 在通过电邮、新闻组或者聊天室提出技术问题前，检查你有没有做到： \\1. 通读手册，试着自己找答案。\\2. 在FAQ里找答案（一份维护得好的FAQ可以包罗万象:）。\\3. 在网上搜索（个人推荐google~）。\\4. 向你身边精于此道的朋友打听。 当你提出问题的时候，首先要说明在此之前你干了些什么；这将有助于树立你的形象：你不是一个妄图不劳而获的乞讨者，不愿浪费别人的时间。如果提问者能从答案中学到东西，我们更乐于回答他的问题。 周全的思考，准备好你的问题，草率的发问只能得到草率的回答，或者根本得不到任何答案。越表现出在寻求帮助前为解决问题付出的努力，你越能得到实质性的帮助。 小心别问错了问题。如果你的问题基于错误的假设，普通黑客（J. Random Hacker）通常会用无意义的字面解释来答复你，心里想着“蠢问题…”，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。 决不要自以为够资格得到答案，你没这种资格。毕竟你没有为这种服务支付任何报酬。你要自己去“挣”回一个答案，靠提出一个有内涵的，有趣的，有思维激励作用的问题–一个对社区的经验有潜在贡献的问题，而不仅仅是被动的从他人处索要知识–去挣到这个答案。 另一方面，表明你愿意在找答案的过程中做点什么，是一个非常好的开端。“谁能给点提示？”、“我这个例子里缺了什么？”以及“我应该检查什么地方？”比“请把确切的过程贴出来”更容易得到答复。因为你显得只要有人指点正确的方向，你就有完成它的能力和决心。 = 怎样提问 = - 谨慎选择论坛 小心选择提问的场合。如果象下面描述的那样，你很可能被忽略掉或者被看作失败者： \\1. 在风马牛不相及的论坛贴出你的问题\\2. 在探讨高级技巧的论坛张贴非常初级的问题；反之亦然\\3. 在太多的不同新闻组交叉张贴 - 用辞贴切，语法正确，拼写无误 我们从经验中发现，粗心的写作者通常也是马虎的思考者（我敢打包票）。 回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。 正确的拼写，标点符号和大小写很重要。 更一般的说，如果你的提问写得象个半文盲，你很有可能被忽视。 如果你在使用非母语的论坛提问，你可以犯点拼写和语法上的小错–但决不能在思考上马虎（没错，我们能弄清两者的分别） - 使用含义丰富，描述准确的标题 在邮件列表或者新闻组中，大约50字以内的主题标题是抓住资深专家注意力 的黄金时机。别用喋喋不休的“帮帮忙”（更别说“救命啊！！！！！”这 样让人反感的话）来浪费这个机会。不要妄想用你的痛苦程度来打动我们， 别用空格代替问题的描述，哪怕是极其简短的描述。 蠢问题： 救命啊！我的膝上机不能正常显示了！ 聪明问题： XFree86 4.1下鼠标光标变形，Fooware MV1005的显示芯片。 如果你在回复中提出问题，记得要修改内容标题，表明里面有一个问题。一个看起来象“Re：测试”或者“Re：新bug”的问题很难引起足够重视。另外，引用并删减前文的内容，给新来的读者留下线索。 - 精确描述，信息量大 \\1. 谨慎明确的描述症状。\\2. 提供问题发生的环境（机器配置、操作系统、应用程序以及别的什么）。\\3. 说明你在提问前是怎样去研究和理解这个问题的。\\4. 说明你在提问前采取了什么步骤去解决它。\\5. 罗列最近做过什么可能有影响的硬件、软件变更。 尽量想象一个黑客会怎样反问你，在提问的时候预先给他答案。 Simon Tatham写过一篇名为《如何有效的报告Bug》的出色短文。强力推荐你也读一读。 - 话不在多 你需要提供精确有效的信息。这并不是要求你简单的把成吨的出错代码或者数据完全转储摘录到你的提问中。如果你有庞大而复杂的测试条件，尽量把它剪裁得越小越好。 这样做的用处至少有三点。第一，表现出你为简化问题付出了努力，这可以使你得 到回答的机会增加；第二，简化问题使你得到有用答案的机会增加；第三，在提炼 你的bug报告的过程中，也许你自己就能找出问题所在或作出更正。 - 只说症状，不说猜想 告诉黑客们你认为问题是怎样引起的没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，不要加进你自己的理解和推论。让黑客们来诊断吧。 蠢问题： 我在内核编译中一次又一次遇到SIG11错误，我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？聪明问题： 我自制的一套K6/233系统，主板是FIC-PA2007 （VIA Apollo VP2芯片组），256MB Corsair PC133 SDRAM，在内核编译中频频产生SIG11错误，从开机20分钟以后就有这种情况，开机 前20分钟内从没发生过。重启也没有用，但是关机一晚上就又能工作20分钟。所有 内存都换过了，没有效果。相关部分的典型编译记录如下…。 - 按时间顺序列出症状 对找出问题最有帮助的线索，往往就是问题发生前的一系列操作，因此，你的说明 应该包含操作步骤，以及电脑的反应，直到问题产生。 如果你的说明很长（超过四个段落），在开头简述问题会有所帮助，接下来按时间顺序详述。这样黑客们就知道该在你的说明中找什么。 - 明白你想问什么 漫无边际的提问近乎无休无止的时间黑洞。最能给你有用答案的人也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞不太感冒，因此也可以说他们对漫无边际的提问不大感冒。 如果你明确表述需要回答者做什么（提供建议，发送一段代码，检查你的补丁或是别的），就最有可能得到有用的答案。这会定出一个时间和精力的上限，便于回答者集中精力来帮你，这很凑效。要理解专家们生活的世界，要把专业技能想象为充裕的资源，而回复的时间则是贫乏的资源。解决你的问题需要的时间越少，越能从忙碌的专家口中掏出答案。 因此，优化问题的结构，尽量减少专家们解决它所需要的时间，会有很大的帮助–这通常和简化问题有所区别。因此，问“我想更好的理解X，能给点提示吗？”通常比问“你能解释一下X吗？”更好。如果你的代码不能工作，问问它有什么地方不对，比要求别人替你修改要明智得多。 - 别问应该自己解决的问题 黑客们总是善于分辨哪些问题应该由你自己解决；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。 - 去除无意义的疑问 别用无意义的话结束提问，例如“有人能帮我吗？”或者“有答案吗？”。 首先：如果你对问题的描述不很合适，这样问更是画蛇添足。其次：由于这 样问是画蛇添足，黑客们会很厌烦你–而且通常会用逻辑上正确的回答来表 示他们的蔑视，例如：“没错，有人能帮你”或者“不，没答案”。 - 谦逊绝没有害处，而且常帮大忙彬 彬有礼，多用“请”和“先道个谢了”。让大家都知道你对他们花费时间义务提供帮助心存感激。然而，如果你有很多问题无法解决，礼貌将会增加你得到有用答案的机会。 （我们注意到，自从本指南发布后，从资深黑客处得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得“先谢了”的言外之意是过后就不会再感谢任何人了。我们的建议是：都道谢。） - 问题解决后，加个简短说明 问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个补充说明。补充说明不必很长或是很深入；简单的一句“你好，原来是网线出了问题！谢谢大家–Bill”比什么也不说要强。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇学术论文更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。除了表示礼貌和反馈信息以外，这种补充有助于他人在邮件列表/新闻组/论坛中搜索对你有过帮助的完整解决方案，这可能对他们也很有用。最后（至少？），这种补充有助于所有提供过帮助的人从中得到满足感。如果你自己不是老手或者黑客，那就相信我们，这种感觉对于那些你向他们求助的导师或者专家而言，是非常重要的。问题久拖未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次贴出新问题时尝到甜头。 - 还是不懂 如果你不是很理解答案，别立刻要求对方解释。象你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），去理解它。如果你真的需要对方解释，记得表现出你已经学到了点什么。比方说，如果我回答你：“看来似乎是zEntry被阻塞了；你应该先清除它。”，然后：一个很糟的后续问题：“zEntry是什么？” 聪明的问法应该是这样：“哦~我看过帮助了但是只有-z和-p两个参数中提到了zEntry而且还都没有清楚的解释:&lt;你是指这两个中的哪一个吗？还是我看漏了什么？” = 三思而后问 = 以下是几个经典蠢问题，以及黑客在拒绝回答时的心中所想： 问题：我能在哪找到X程序？问题：我的程序/配置/SQL申明没有用问题：我的Windows有问题，你能帮我吗？问题：我在安装Linux（或者X）时有问题，你能帮我吗？问题：我怎么才能破解root帐号/窃取OP特权/读别人的邮件呢？ 提问：我能在哪找到X程序？回答：就在我找到它的地方啊蠢货–搜索引擎的那一头。天呐！还有人不会用Google吗？ 提问：我的程序（配置、SQL申明）没有用回答：这不算是问题吧，我对找出你的真正问题没兴趣–如果要我问你二十个问题才找得出来的话–我有更有意思的事要做呢。 在看到这类问题的时候，我的反应通常不外如下三种： \\1. 你还有什么要补充的吗？\\2. 真糟糕，希望你能搞定。\\3. 这跟我有什么鸟相关？ 提问：我的Windows有问题，你能帮我吗？回答：能啊，扔掉萎软的垃圾，换Linux吧。 提问：我在安装Linux（或者X）时有问题，你能帮我吗？回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的Linux用户组寻求手把手的指导吧（你能在这儿找到用户组的清单）。 提问：我怎么才能破解root帐号/窃取OP特权/读别人的邮件呢？回答：想要这样做，说明你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！ **= 好问题，坏问题 =** 最后，我举一些例子来说明，怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。 蠢问题：我可以在哪儿找到关于Foonly Flurbamatic的资料？// 这种问法无非想得到“STFW”这样的回答。 聪明问题：我用Google搜索过“Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？// 这个问题已经STFW过了，看起来他真的遇到了麻烦。 蠢问题：我从FOO项目找来的源码没法编译。它怎么这么烂？// 他觉得都是别人的错，这个傲慢自大的家伙 聪明问题：FOO项目代码在Nulix 6.2版下无法编译通过。我读过了FAQ，但里面没有提到跟Nulix有关的问题。这是我编译过程的记录，我有什么做得不对的地方吗？// 他讲明了环境，也读过了FAQ，还指明了错误，并且他没有把问题的责任推到别人头上，这个家伙值得留意。 蠢问题：我的主板有问题了，谁来帮我？// 普通黑客对这类问题的回答通常是：“好的，还要帮你拍拍背和换尿布吗？” ，然后按下删除键。 聪明问题：我在S2464主板上试过了X、Y和Z，但没什么作用，我又试了A、B和C。请注意当我尝试C时的奇怪现象。显然边带传输中出现了收缩，但结果出人意料。在多处理器主板上引起边带泄漏的通常原因是什么？谁有好主意接下来我该做些什么测试才能找出问题？// 这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。 在最后一个问题中，注意“告诉我答案”和“给我启示，指出我还应该做什么诊断工作”之间微妙而又重要的区别。事实上，后一个问题源自于2001年8月在Linux内核邮件列表上的一个真实的提问。我（Eric）就是那个提出问题的人。我在Tyan S2464主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决那一问题的重要信息。 通过我的提问方法，我给了大家值得玩味的东西；我让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，邀请他们与我共同探讨。我告诉他们我所走过的弯路，以避免他们再浪费时间，这是一种对他人时间价值的尊重。后来，当我向每个人表示感谢，并且赞赏这套程序（指邮件列表中的讨论 –译者注）运作得非常出色的时候，一个Linux内核邮件列（lkml）成员表示，问题得到解决并非由于我是这个列表中的“名人”，而是因为我用了正确的方式来提问。我们黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我象个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，给编写这个指南的人一些指导。 = 找不到答案怎么办 = 如果仍得不到答案，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。 总的说来，简单的重复张贴问题是个很糟的想法。这将被视为无意义的喧闹。 你可以通过其它渠道获得帮助，这些渠道通常更适合初学者的需要。有许多网上的以及本地的用户组，由狂热的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。 另外，你可以向很多商业公司寻求帮助，不论公司大还是小（Red Hat 和LinuxCare 就是两个最常见的例子）。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了–完全可能如此–你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。 对大众化的软件，就象Linux之类而言，每个开发者至少会有上万名用户。根本不可能由一个人来处理来自上万名用户的求助电话。要知道，即使你要为帮助付费，同你必须购买同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开放源代码软件要高得多，且内容也不那么丰富）。 Copyright (C) 2001 by Eric S. Raymond中文版 Copyleft 2001 by D.H.Grand(nOBODY/Ginux)英文版：感谢 Eric 的耐心指点和同意，本文才得以完成并发布，本指南 英文版版权为 Eric Steven Raymond 所有，中文版版权由 D.H.Grand[nOBODY/Ginux] 所有"},{"title":"hexo下markdown使用语法记录","date":"2019-11-26T04:52:15.000Z","url":"/2019/11/26/markdown%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":"markdown是什么Markdown 是一种轻量级标记语言，支持纯文本编写；后缀是.md或.markdown。 语法 1.标题 2.字体 斜体文本粗体文本粗斜体文本删除线 3.分割线 4.列表 第一行 第二行 5.区块 6.链接 链接我的blog 7.代码块 8.插入图片 使用它要安装插件 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 例子 9.表格 &lt;br&gt;代表换行 a b 1 ab 2 cd 10.插入视频使用插件 例子 pic是视频未播放时的封面 用html的&lt;video&gt;标签 src既可以是分享的网络视频，也可以是资源文件下的视频 hexo常用命令1.hexo文章的多标签 2.设置草稿建立文章草稿 本机预览草稿 将文章从 source/_drafts 移动到 source/_posts "},{"title":"常见正则表达式记录","date":"2019-11-25T14:34:33.000Z","url":"/2019/11/25/%E5%B8%B8%E8%A7%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%B0%E5%BD%95/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":" 常见转义字符 \\n \\t \\ 等 如果要匹配字符本身的话就需要转义 为什么需要转义，因为这些字符在正则表达式中都有特殊含义，转义是为了不产生混淆 转义只需要在前加\\，表示匹配本身 常见字符 \\d 任意一个数字0到9 \\w 任意一个字母数字下划线 \\s 任意一个空白符(空格、制表、换行) \\S 任意一个空白符之外 [\\s\\S] \\b 匹配单词的开始或结束 \\bword\\b ^ 匹配字符串的开始 $ 匹配字符串的结束 . 任意字符（除换行） ？ {0,1} + {1,} * {0,} | 或 &amp;&amp; 类似c的逻辑&amp;&amp; 注意[]中除了^其他符号都没有了特殊意义 贪婪 尽量匹配更多的字符 非贪婪（加上？) 与贪婪相反 下面列举一些常用的正则 几种处理模式 "},{"title":"win下搭建hexo博客","date":"2019-11-24T09:42:34.000Z","url":"/2019/11/24/win%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":"HexoHexo是一款静态博客框架，安装起来很方便。把 hexo的静态网页上传到GitHub ，就很方便的搭建出可自定义的博客。 下面分享一下在win10下部署步骤，希望有帮助。 步骤 1.安装nodejs(hexo依赖nodejs) 2.安装git 3.安装hexo框架 4.配置博客 5.本地运行 6.将代码托管到github 1.安装nodejs去nodejs官网进行下载  安装完成后，cmd进入对应的安装目录检查一下是否安装成功 node -v npm -v 2.安装gitgit官网下载 ​  同样看一下版本信息，检查是否安装成功 ​ git --version 3.安装hexo框架注意：nodejs和git的安装路径自定，但安装hexo时cmd路径在nodejs路径下 npm install -g hexo-cli 安装完成用hexo -v检查是否安装成功 4.配置博客安装好后进行配置(此时路径还是在nodejs安装路径下) 先新建一个放博客的文件(名字自定，这里我用blog) mkdir blog 初始化（初始化时要保证初始化的文件夹是空的） hexo init blog 完成后安装nmp cd blog npm install 新建后的目录功能： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的模板 source：用来存放你的文章 themes：主题文件 _config.yml: 博客的配置文件 5.本地运行用git-cmd.exe对博客进行管理(此时路径在nodejs\\blog下) 输入 ​ hexo -g ​ hexo -s 浏览器输入localhost:4000就能在本地查看博客 一些常用命令意思 hexo clean //或hexo c清除缓存 hexo generate1 //或hexo g编译 hexo server*//或 hexo s* 运行服务 hexo d //上传到github仓库（这里还不行，要完成下一步配置才能用） 按ctrl+c停止服务 6.将代码托管到github注册一个github账号， 创建代码仓库，按规定申请地址 用户名.github.io 比如我的github名称是xy-bz ,地址栏填 xy-bz.github.io 在博客路径（我的是blog）下安装一个git的插件（用git-cmd.exe） ​ npm install hexo-deployer-git –save 修改下博客配置文件 _config.yml 把申请的仓库地址加进去 repo:后就是的代码仓库地址 注意：冒号后面有一个空格，这个是格式 最后部署 hexo d 在浏览器输入仓库的地址就能看到了 我的博客"}]